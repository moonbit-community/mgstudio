// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mgstudio/render2d"

import {
  "Milky2018/mgstudio/app",
  "Milky2018/mgstudio/asset",
  "Milky2018/mgstudio/core",
  "Milky2018/mgstudio/math",
  "Milky2018/mgstudio/mesh",
  "Milky2018/mgstudio/transform",
}

// Values
pub let ecs_components : Array[String]

pub let ecs_resources : Array[String]

pub fn gizmo_config() -> GizmoConfig

pub fn gizmo_set_config(GizmoConfig) -> Unit

pub fn[W] render2d_camera_system(W) -> Unit

pub fn render2d_camera_viewport_to_world_2d(@math.Vec2, Camera2d, @math.Transform, @math.IVec2, Float) -> @math.Vec2?

pub fn render2d_camera_world_to_viewport_2d(@math.Vec2, Camera2d, @math.Transform, @math.IVec2, Float) -> @math.Vec2?

pub fn[W : HasRes_RenderState + @core.ChangeTickWorld] render2d_clear_overlay_sprites(W) -> Unit

pub fn[W : HasRes_RenderState + @core.ChangeTickWorld] render2d_create_render_target(W, Int, Int, Bool) -> @asset.Handle[@asset.Image]

pub fn[W : HasRes_RenderState] render2d_debug_log_primary_camera(W) -> Unit

pub fn[W : HasRes_RenderState + Has_Camera2d + Has_RenderTarget + Has_RenderLayers + Has_Sprite + Has_SpriteTexture + Has_Mesh2d + Has_ColorMaterial + Has_GpuMesh2d + @math.Has_Transform + @transform.Has_GlobalTransform + @asset.Has_TextureAtlas + @core.ChangeTickWorld] render2d_plugin(@app.App[W]) -> @app.App[W]

pub fn[W : HasRes_RenderState + @core.ChangeTickWorld] render2d_push_sprite_uv(W, @asset.Handle[@asset.Image], @math.Transform, @math.Vec2, @math.Vec2, Color, RenderLayers) -> Unit

pub fn[W : HasRes_RenderState] render2d_viewport_to_world_2d(W, @math.Vec2) -> @math.Vec2?

pub fn[W : HasRes_RenderState] render2d_world_to_viewport(W, @math.Vec2) -> @math.Vec2?

pub fn[W : HasRes_RenderState + @core.ChangeTickWorld] render_execute_system(W) -> Unit

pub fn[W : HasRes_RenderState + Has_Camera2d + Has_RenderTarget + Has_RenderLayers + Has_Sprite + Has_SpriteTexture + Has_Mesh2d + Has_ColorMaterial + Has_GpuMesh2d + @math.Has_Transform + @transform.Has_GlobalTransform + @asset.Has_TextureAtlas + @core.ChangeTickWorld] render_extract_system(W) -> Unit

pub fn[W] render_prepare_system(W) -> Unit

pub fn[W] render_queue_system(W) -> Unit

// Errors

// Types and methods
pub struct Arc2dBuilder {
  id : Int
}
pub fn Arc2dBuilder::resolution(Self, Int) -> Self

pub struct ArrowBuilder {
  id : Int
}
pub fn ArrowBuilder::with_double_end(Self) -> Self
pub fn ArrowBuilder::with_tip_length(Self, Float) -> Self

pub struct Camera2d {
  clear_color : Color
  order : Int
  scale : Float
  viewport : Viewport?
}
pub fn Camera2d::clear_viewport(Self) -> Self
pub fn Camera2d::default() -> Self
pub fn Camera2d::new(Color) -> Self
pub fn Camera2d::with_order(Self, Int) -> Self
pub fn Camera2d::with_scale(Self, Float) -> Self
pub fn Camera2d::with_viewport(Self, Viewport) -> Self

pub struct Camera2dBundle {
  camera : Camera2d
  transform : @math.Transform
  target : RenderTarget
  layers : RenderLayers
}
pub fn Camera2dBundle::new(Camera2d, @math.Transform) -> Self
pub fn Camera2dBundle::new_with_layers(Camera2d, @math.Transform, RenderTarget, RenderLayers) -> Self
pub fn Camera2dBundle::new_with_target(Camera2d, @math.Transform, RenderTarget) -> Self
pub fn[W : @core.SpawnWorld + @core.ChangeTickWorld + Has_Camera2d + Has_RenderTarget + Has_RenderLayers + @math.Has_Transform] Camera2dBundle::spawn(Self, W) -> @core.Entity

pub struct Capsule2d {
  radius : Float
  half_length : Float
  segments : Int
}
pub fn Capsule2d::default() -> Self
pub fn Capsule2d::new(Float, Float, Int) -> Self

pub struct Color {
  r : Float
  g : Float
  b : Float
  a : Float
}
pub fn Color::black() -> Self
pub fn Color::new(Float, Float, Float, Float) -> Self
pub fn Color::white() -> Self

pub struct ColorMaterial {
  color : Color
}
pub fn ColorMaterial::new(Color) -> Self

pub struct Ellipse2dBuilder {
  id : Int
}
pub fn Ellipse2dBuilder::resolution(Self, Int) -> Self

pub(all) struct GizmoConfig {
  enabled : Bool
  line : GizmoLineConfig
  depth_bias : Float
  render_layers : RenderLayers
}
pub fn GizmoConfig::default() -> Self

pub(all) struct GizmoLineConfig {
  width : Float
  perspective : Bool
  style : GizmoLineStyle
  joints : GizmoLineJoint
}
pub fn GizmoLineConfig::default() -> Self

pub(all) enum GizmoLineJoint {
  None
  Miter
  Round(Int)
  Bevel
}

pub(all) enum GizmoLineStyle {
  Solid
  Dotted
  Dashed(gap_scale~ : Float, line_scale~ : Float)
}

pub struct Gizmos {
  layers : RenderLayers
}
pub fn Gizmos::arc_2d(Self, Isometry2d, Float, Float, Color) -> Arc2dBuilder
pub fn Gizmos::arrow_2d(Self, @math.Vec2, @math.Vec2, Color) -> ArrowBuilder
pub fn Gizmos::axes_2d(Self, Isometry2d, Float) -> Unit
pub fn Gizmos::circle_2d(Self, Isometry2d, Float, Color) -> Ellipse2dBuilder
pub fn Gizmos::cross_2d(Self, Isometry2d, Float, Color) -> Unit
pub fn Gizmos::curve_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::curve_gradient_2d(Self, Array[(@math.Vec2, Color)]) -> Unit
pub fn Gizmos::ellipse_2d(Self, Isometry2d, @math.Vec2, Color) -> Ellipse2dBuilder
pub fn Gizmos::grid_2d(Self, Isometry2d, @math.IVec2, @math.Vec2, Color) -> Grid2dBuilder
pub fn Gizmos::line_2d(Self, @math.Vec2, @math.Vec2, Color) -> Unit
pub fn Gizmos::line_gradient_2d(Self, @math.Vec2, @math.Vec2, Color, Color) -> Unit
pub fn Gizmos::lineloop_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::linestrip_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::linestrip_gradient_2d(Self, Array[(@math.Vec2, Color)]) -> Unit
pub fn Gizmos::long_arc_2d_between(Self, @math.Vec2, @math.Vec2, @math.Vec2, Color) -> Arc2dBuilder
pub fn Gizmos::new() -> Self
pub fn Gizmos::ray_2d(Self, @math.Vec2, @math.Vec2, Color) -> Unit
pub fn Gizmos::ray_gradient_2d(Self, @math.Vec2, @math.Vec2, Color, Color) -> Unit
pub fn Gizmos::rect_2d(Self, Isometry2d, @math.Vec2, Color) -> Unit
pub fn Gizmos::rounded_rect_2d(Self, Isometry2d, @math.Vec2, Color) -> RoundedRectBuilder
pub fn Gizmos::short_arc_2d_between(Self, @math.Vec2, @math.Vec2, @math.Vec2, Color) -> Arc2dBuilder
pub fn Gizmos::with_layers(Self, RenderLayers) -> Self
pub impl @app.SystemParam for Gizmos

pub struct GpuMesh2d {
  mesh_id : Int
}
pub fn GpuMesh2d::new(Int) -> Self

pub struct Grid2dBuilder {
  id : Int
}
pub fn Grid2dBuilder::outer_edges(Self) -> Self
pub fn Grid2dBuilder::outer_edges_x(Self) -> Self
pub fn Grid2dBuilder::outer_edges_y(Self) -> Self
pub fn Grid2dBuilder::skew(Self, @math.Vec2) -> Self
pub fn Grid2dBuilder::skew_x(Self, Float) -> Self
pub fn Grid2dBuilder::skew_y(Self, Float) -> Self

pub struct Isometry2d {
  translation : @math.Vec2
  rotation : Float
}
pub fn Isometry2d::identity() -> Self
pub fn Isometry2d::new(@math.Vec2, Float) -> Self
pub fn Isometry2d::transform_point(Self, @math.Vec2) -> @math.Vec2

pub struct Mesh2d {
  kind : Mesh2dKind
}
pub fn Mesh2d::from_capsule(Capsule2d) -> Self
pub fn Mesh2d::from_geometry(@mesh.Mesh2dGeometry) -> Self
pub fn Mesh2d::from_rectangle(Rectangle) -> Self

pub struct Mesh2dBundle {
  mesh : Mesh2d
  material : ColorMaterial
  transform : @math.Transform
  layers : RenderLayers
}
pub fn Mesh2dBundle::new(Mesh2d, ColorMaterial, @math.Transform) -> Self
pub fn Mesh2dBundle::new_with_layers(Mesh2d, ColorMaterial, @math.Transform, RenderLayers) -> Self
pub fn[W : @core.SpawnWorld + @core.ChangeTickWorld + Has_Mesh2d + Has_ColorMaterial + Has_GpuMesh2d + Has_RenderLayers + @math.Has_Transform] Mesh2dBundle::spawn(Self, W) -> @core.Entity

pub(all) enum Mesh2dKind {
  Capsule(Capsule2d)
  Rectangle(Rectangle)
  Geometry(@mesh.Mesh2dGeometry)
}

pub struct Rectangle {
  half_size : @math.Vec2
}
pub fn Rectangle::default() -> Self
pub fn Rectangle::from_size(@math.Vec2) -> Self
pub fn Rectangle::new(Float, Float) -> Self

pub struct RenderLayers {
  mask : Int
}
pub fn RenderLayers::default() -> Self
pub fn RenderLayers::layer(Int) -> Self
pub fn RenderLayers::matches(Self, Self) -> Bool

type RenderState

pub(all) enum RenderTarget {
  Screen
  Image(@asset.Handle[@asset.Image])
}

pub struct RoundedRectBuilder {
  id : Int
}
pub fn RoundedRectBuilder::arc_resolution(Self, Int) -> Self
pub fn RoundedRectBuilder::corner_radius(Self, Float) -> Self

pub struct Sprite {
  color : Color
}
pub fn Sprite::new(Color) -> Self

pub struct SpriteBundle {
  sprite : Sprite
  transform : @math.Transform
  texture : @asset.Handle[@asset.Image]
  layers : RenderLayers
}
pub fn SpriteBundle::new(Sprite, @math.Transform, @asset.Handle[@asset.Image]) -> Self
pub fn SpriteBundle::new_with_layers(Sprite, @math.Transform, @asset.Handle[@asset.Image], RenderLayers) -> Self
pub fn[W : @core.SpawnWorld + @core.ChangeTickWorld + Has_Sprite + Has_SpriteTexture + Has_RenderLayers + @math.Has_Transform] SpriteBundle::spawn(Self, W) -> @core.Entity

pub struct SpriteTexture {
  texture : @asset.Handle[@asset.Image]
}
pub fn SpriteTexture::new(@asset.Handle[@asset.Image]) -> Self

pub struct Viewport {
  physical_position : @math.IVec2
  physical_size : @math.IVec2
}
pub fn Viewport::new(@math.IVec2, @math.IVec2) -> Self

// Type aliases

// Traits
pub(open) trait HasRes_RenderState {
  get_render_state_resource(Self) -> @core.Resource[RenderState]
}

pub(open) trait Has_Camera2d {
  get_camera2d_store(Self) -> @core.ComponentStore[Camera2d]
}

pub(open) trait Has_ColorMaterial {
  get_color_material_store(Self) -> @core.ComponentStore[ColorMaterial]
}

pub(open) trait Has_GpuMesh2d {
  get_gpu_mesh2d_store(Self) -> @core.ComponentStore[GpuMesh2d]
}

pub(open) trait Has_Mesh2d {
  get_mesh2d_store(Self) -> @core.ComponentStore[Mesh2d]
}

pub(open) trait Has_RenderLayers {
  get_render_layers_store(Self) -> @core.ComponentStore[RenderLayers]
}

pub(open) trait Has_RenderTarget {
  get_render_target_store(Self) -> @core.ComponentStore[RenderTarget]
}

pub(open) trait Has_Sprite {
  get_sprite_store(Self) -> @core.ComponentStore[Sprite]
}

pub(open) trait Has_SpriteTexture {
  get_sprite_texture_store(Self) -> @core.ComponentStore[SpriteTexture]
}

