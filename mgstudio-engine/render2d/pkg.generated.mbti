// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mgstudio/render2d"

import {
  "Milky2018/mgstudio/app",
  "Milky2018/mgstudio/asset",
  "Milky2018/mgstudio/math",
  "Milky2018/mgstudio/mesh",
}

// Values
pub fn gizmo_config() -> GizmoConfig

pub fn gizmo_set_config(GizmoConfig) -> Unit

pub fn[W] render2d_camera_system(W) -> Unit

pub fn render2d_clear_overlay_sprites() -> Unit

pub fn render2d_create_render_target(Int, Int, Bool) -> @asset.Handle[@asset.Image]

pub fn render2d_debug_log_primary_camera() -> Unit

pub fn[W] render2d_plugin(@app.App[W]) -> @app.App[W]

pub fn render2d_push_sprite_uv(@asset.Handle[@asset.Image], @math.Transform, @math.Vec2, @math.Vec2, Color, RenderLayers) -> Unit

pub fn render2d_reset() -> Unit

pub fn render2d_set_camera_scale(Float) -> Unit

pub fn render2d_set_camera_scale_handle(CameraHandle, Float) -> Unit

pub fn render2d_set_camera_transform(@math.Transform) -> Unit

pub fn render2d_set_camera_transform_handle(CameraHandle, @math.Transform) -> Unit

pub fn render2d_set_camera_viewport(Viewport?) -> Unit

pub fn render2d_set_camera_viewport_handle(CameraHandle, Viewport?) -> Unit

pub fn render2d_set_mesh_transform_handle(MeshHandle, @math.Transform) -> Unit

pub fn render2d_set_sprite_atlas(@asset.Handle[@asset.TextureAtlasLayout], Int) -> Bool

pub fn render2d_set_sprite_atlas_handle(SpriteHandle, @asset.Handle[@asset.TextureAtlasLayout], Int) -> Bool

pub fn render2d_set_sprite_transform(@math.Transform) -> Unit

pub fn render2d_set_sprite_transform_handle(SpriteHandle, @math.Transform) -> Unit

pub fn render2d_set_sprite_uv(@math.Vec2, @math.Vec2) -> Unit

pub fn render2d_set_sprite_uv_handle(SpriteHandle, @math.Vec2, @math.Vec2) -> Unit

pub fn render2d_spawn_camera(Camera2dBundle) -> CameraHandle

pub fn render2d_spawn_mesh(Mesh2dBundle) -> MeshHandle

pub fn render2d_spawn_sprite(SpriteBundle) -> SpriteHandle

pub fn render2d_viewport_to_world_2d(@math.Vec2) -> @math.Vec2?

pub fn render2d_world_to_viewport(@math.Vec2) -> @math.Vec2?

pub fn[W] render_execute_system(W) -> Unit

pub fn[W] render_extract_system(W) -> Unit

pub fn[W] render_prepare_system(W) -> Unit

pub fn[W] render_queue_system(W) -> Unit

// Errors

// Types and methods
pub struct Arc2dBuilder {
  id : Int
}
pub fn Arc2dBuilder::resolution(Self, Int) -> Self

pub struct ArrowBuilder {
  id : Int
}
pub fn ArrowBuilder::with_double_end(Self) -> Self
pub fn ArrowBuilder::with_tip_length(Self, Float) -> Self

pub struct Camera2d {
  clear_color : Color
  order : Int
  scale : Float
  viewport : Viewport?
}
pub fn Camera2d::clear_viewport(Self) -> Self
pub fn Camera2d::default() -> Self
pub fn Camera2d::new(Color) -> Self
pub fn Camera2d::with_order(Self, Int) -> Self
pub fn Camera2d::with_scale(Self, Float) -> Self
pub fn Camera2d::with_viewport(Self, Viewport) -> Self

pub struct Camera2dBundle {
  camera : Camera2d
  transform : @math.Transform
  target : RenderTarget
  layers : RenderLayers
}
pub fn Camera2dBundle::new(Camera2d, @math.Transform) -> Self
pub fn Camera2dBundle::new_with_layers(Camera2d, @math.Transform, RenderTarget, RenderLayers) -> Self
pub fn Camera2dBundle::new_with_target(Camera2d, @math.Transform, RenderTarget) -> Self
pub fn Camera2dBundle::spawn(Self) -> CameraHandle

pub struct CameraHandle {
  id : Int
}
pub fn CameraHandle::new(Int) -> Self

pub struct Capsule2d {
  radius : Float
  half_length : Float
  segments : Int
}
pub fn Capsule2d::default() -> Self
pub fn Capsule2d::new(Float, Float, Int) -> Self

pub struct Color {
  r : Float
  g : Float
  b : Float
  a : Float
}
pub fn Color::black() -> Self
pub fn Color::new(Float, Float, Float, Float) -> Self
pub fn Color::white() -> Self

pub struct ColorMaterial {
  color : Color
}
pub fn ColorMaterial::new(Color) -> Self

pub struct Ellipse2dBuilder {
  id : Int
}
pub fn Ellipse2dBuilder::resolution(Self, Int) -> Self

pub(all) struct GizmoConfig {
  enabled : Bool
  line : GizmoLineConfig
  depth_bias : Float
  render_layers : RenderLayers
}
pub fn GizmoConfig::default() -> Self

pub(all) struct GizmoLineConfig {
  width : Float
  perspective : Bool
  style : GizmoLineStyle
  joints : GizmoLineJoint
}
pub fn GizmoLineConfig::default() -> Self

pub(all) enum GizmoLineJoint {
  None
  Miter
  Round(Int)
  Bevel
}

pub(all) enum GizmoLineStyle {
  Solid
  Dotted
  Dashed(gap_scale~ : Float, line_scale~ : Float)
}

pub struct Gizmos {
  layers : RenderLayers
}
pub fn Gizmos::arc_2d(Self, Isometry2d, Float, Float, Color) -> Arc2dBuilder
pub fn Gizmos::arrow_2d(Self, @math.Vec2, @math.Vec2, Color) -> ArrowBuilder
pub fn Gizmos::axes_2d(Self, Isometry2d, Float) -> Unit
pub fn Gizmos::circle_2d(Self, Isometry2d, Float, Color) -> Ellipse2dBuilder
pub fn Gizmos::cross_2d(Self, Isometry2d, Float, Color) -> Unit
pub fn Gizmos::curve_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::curve_gradient_2d(Self, Array[(@math.Vec2, Color)]) -> Unit
pub fn Gizmos::ellipse_2d(Self, Isometry2d, @math.Vec2, Color) -> Ellipse2dBuilder
pub fn Gizmos::grid_2d(Self, Isometry2d, @math.IVec2, @math.Vec2, Color) -> Grid2dBuilder
pub fn Gizmos::line_2d(Self, @math.Vec2, @math.Vec2, Color) -> Unit
pub fn Gizmos::line_gradient_2d(Self, @math.Vec2, @math.Vec2, Color, Color) -> Unit
pub fn Gizmos::lineloop_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::linestrip_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::linestrip_gradient_2d(Self, Array[(@math.Vec2, Color)]) -> Unit
pub fn Gizmos::long_arc_2d_between(Self, @math.Vec2, @math.Vec2, @math.Vec2, Color) -> Arc2dBuilder
pub fn Gizmos::new() -> Self
pub fn Gizmos::ray_2d(Self, @math.Vec2, @math.Vec2, Color) -> Unit
pub fn Gizmos::ray_gradient_2d(Self, @math.Vec2, @math.Vec2, Color, Color) -> Unit
pub fn Gizmos::rect_2d(Self, Isometry2d, @math.Vec2, Color) -> Unit
pub fn Gizmos::rounded_rect_2d(Self, Isometry2d, @math.Vec2, Color) -> RoundedRectBuilder
pub fn Gizmos::short_arc_2d_between(Self, @math.Vec2, @math.Vec2, @math.Vec2, Color) -> Arc2dBuilder
pub fn Gizmos::with_layers(Self, RenderLayers) -> Self
pub impl @app.SystemParam for Gizmos

pub struct Grid2dBuilder {
  id : Int
}
pub fn Grid2dBuilder::outer_edges(Self) -> Self
pub fn Grid2dBuilder::outer_edges_x(Self) -> Self
pub fn Grid2dBuilder::outer_edges_y(Self) -> Self
pub fn Grid2dBuilder::skew(Self, @math.Vec2) -> Self
pub fn Grid2dBuilder::skew_x(Self, Float) -> Self
pub fn Grid2dBuilder::skew_y(Self, Float) -> Self

pub struct Isometry2d {
  translation : @math.Vec2
  rotation : Float
}
pub fn Isometry2d::identity() -> Self
pub fn Isometry2d::new(@math.Vec2, Float) -> Self
pub fn Isometry2d::transform_point(Self, @math.Vec2) -> @math.Vec2

pub struct Mesh2d {
  kind : Mesh2dKind
}
pub fn Mesh2d::from_capsule(Capsule2d) -> Self
pub fn Mesh2d::from_geometry(@mesh.Mesh2dGeometry) -> Self
pub fn Mesh2d::from_rectangle(Rectangle) -> Self

pub struct Mesh2dBundle {
  mesh : Mesh2d
  material : ColorMaterial
  transform : @math.Transform
  layers : RenderLayers
}
pub fn Mesh2dBundle::new(Mesh2d, ColorMaterial, @math.Transform) -> Self
pub fn Mesh2dBundle::new_with_layers(Mesh2d, ColorMaterial, @math.Transform, RenderLayers) -> Self
pub fn Mesh2dBundle::spawn(Self) -> MeshHandle

pub(all) enum Mesh2dKind {
  Capsule(Capsule2d)
  Rectangle(Rectangle)
  Geometry(@mesh.Mesh2dGeometry)
}

pub struct MeshHandle {
  id : Int
}
pub fn MeshHandle::new(Int) -> Self

pub struct Rectangle {
  half_size : @math.Vec2
}
pub fn Rectangle::default() -> Self
pub fn Rectangle::from_size(@math.Vec2) -> Self
pub fn Rectangle::new(Float, Float) -> Self

pub struct RenderLayers {
  mask : Int
}
pub fn RenderLayers::default() -> Self
pub fn RenderLayers::layer(Int) -> Self
pub fn RenderLayers::matches(Self, Self) -> Bool

pub(all) enum RenderTarget {
  Screen
  Image(@asset.Handle[@asset.Image])
}

pub struct RoundedRectBuilder {
  id : Int
}
pub fn RoundedRectBuilder::arc_resolution(Self, Int) -> Self
pub fn RoundedRectBuilder::corner_radius(Self, Float) -> Self

pub struct Sprite {
  color : Color
}
pub fn Sprite::new(Color) -> Self

pub struct SpriteBundle {
  sprite : Sprite
  transform : @math.Transform
  texture : @asset.Handle[@asset.Image]
  layers : RenderLayers
}
pub fn SpriteBundle::new(Sprite, @math.Transform, @asset.Handle[@asset.Image]) -> Self
pub fn SpriteBundle::new_with_layers(Sprite, @math.Transform, @asset.Handle[@asset.Image], RenderLayers) -> Self
pub fn SpriteBundle::spawn(Self) -> SpriteHandle

pub struct SpriteHandle {
  id : Int
}
pub fn SpriteHandle::new(Int) -> Self

pub struct Viewport {
  physical_position : @math.IVec2
  physical_size : @math.IVec2
}
pub fn Viewport::new(@math.IVec2, @math.IVec2) -> Self

// Type aliases

// Traits

