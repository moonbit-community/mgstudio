// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mgstudio/render2d"

import {
  "Milky2018/mgstudio/app",
  "Milky2018/mgstudio/asset",
  "Milky2018/mgstudio/core",
  "Milky2018/mgstudio/math",
  "Milky2018/mgstudio/mesh",
  "Milky2018/mgstudio/transform",
  "Milky2018/mgstudio/visibility",
}

// Values
pub let ecs_components : Array[String]

pub let ecs_resources : Array[String]

pub fn gizmo_config() -> GizmoConfig

pub fn gizmo_set_config(GizmoConfig) -> Unit

pub fn[W] render2d_camera_system(W) -> Unit

pub fn render2d_camera_viewport_to_world_2d(@math.Vec2, Camera, OrthographicProjection, @math.Transform, @math.IVec2, Float) -> @math.Vec2?

pub fn render2d_camera_world_to_viewport_2d(@math.Vec2, Camera, OrthographicProjection, @math.Transform, @math.IVec2, Float) -> @math.Vec2?

pub fn[W : HasRes_RenderState + @core.ChangeTickWorld] render2d_clear_overlay_sprites(W) -> Unit

pub fn[W : HasRes_RenderState + @core.ChangeTickWorld] render2d_create_render_target(W, Int, Int, Bool) -> @asset.Handle[@asset.Image]

pub fn[W : HasRes_RenderState] render2d_debug_log_primary_camera(W) -> Unit

pub fn[W : HasRes_RenderState + Has_Camera2d + Has_Camera + Has_Projection + Has_RenderTarget + Has_RenderLayers + Has_Sprite + Has_Anchor + Has_Mesh2d + Has_ColorMaterial + Has_GpuMesh2d + @math.Has_Transform + @transform.Has_GlobalTransform + @visibility.Has_ViewVisibility + @core.ChangeTickWorld] render2d_plugin(@app.App[W]) -> @app.App[W]

pub fn[W : HasRes_RenderState + @core.ChangeTickWorld] render2d_push_sprite_uv(W, @asset.Handle[@asset.Image], @math.Transform, @math.Vec2, @math.Vec2, Color, RenderLayers) -> Unit

pub fn[W : HasRes_RenderState] render2d_viewport_to_world_2d(W, @math.Vec2) -> @math.Vec2?

pub fn[W : HasRes_RenderState] render2d_world_to_viewport(W, @math.Vec2) -> @math.Vec2?

pub fn[W : HasRes_RenderState + @core.ChangeTickWorld] render_execute_system(W) -> Unit

pub fn[W : HasRes_RenderState + Has_Camera2d + Has_Camera + Has_Projection + Has_RenderTarget + Has_RenderLayers + Has_Sprite + Has_Anchor + Has_Mesh2d + Has_ColorMaterial + Has_GpuMesh2d + @math.Has_Transform + @transform.Has_GlobalTransform + @visibility.Has_ViewVisibility + @core.ChangeTickWorld] render_extract_system(W) -> Unit

pub fn[W] render_prepare_system(W) -> Unit

pub fn[W] render_queue_system(W) -> Unit

// Errors

// Types and methods
pub struct Anchor {
  value : @math.Vec2
}
pub fn Anchor::as_vec(Self) -> @math.Vec2
pub fn Anchor::bottom_center() -> Self
pub fn Anchor::bottom_left() -> Self
pub fn Anchor::bottom_right() -> Self
pub fn Anchor::center() -> Self
pub fn Anchor::center_left() -> Self
pub fn Anchor::center_right() -> Self
pub fn Anchor::default() -> Self
pub fn Anchor::new(@math.Vec2) -> Self
pub fn Anchor::top_center() -> Self
pub fn Anchor::top_left() -> Self
pub fn Anchor::top_right() -> Self

pub struct Arc2dBuilder {
  id : Int
}
pub fn Arc2dBuilder::resolution(Self, Int) -> Self

pub struct ArrowBuilder {
  id : Int
}
pub fn ArrowBuilder::with_double_end(Self) -> Self
pub fn ArrowBuilder::with_tip_length(Self, Float) -> Self

pub struct Camera {
  viewport : Viewport?
  order : Int
  clear_color : Color
}
pub fn Camera::clear_viewport(Self) -> Self
pub fn Camera::default() -> Self
pub fn Camera::new(Color) -> Self
pub fn Camera::with_order(Self, Int) -> Self
pub fn Camera::with_viewport(Self, Viewport) -> Self

pub struct Camera2d {
}
pub fn Camera2d::default() -> Self

pub struct Camera2dBundle {
  camera : Camera
  projection : Projection
  camera2d : Camera2d
  transform : @math.Transform
  target : RenderTarget
  layers : RenderLayers
}
pub fn Camera2dBundle::new(Camera, @math.Transform) -> Self
pub fn Camera2dBundle::new_with_layers(Camera, @math.Transform, RenderTarget, RenderLayers) -> Self
pub fn Camera2dBundle::new_with_projection(Camera, Projection, @math.Transform) -> Self
pub fn Camera2dBundle::new_with_target(Camera, @math.Transform, RenderTarget) -> Self
pub fn[W : @core.SpawnWorld + @core.ChangeTickWorld + Has_Camera2d + Has_Camera + Has_Projection + Has_RenderTarget + Has_RenderLayers + @math.Has_Transform] Camera2dBundle::spawn(Self, W) -> @core.Entity

pub struct Capsule2d {
  radius : Float
  half_length : Float
  segments : Int
}
pub fn Capsule2d::default() -> Self
pub fn Capsule2d::new(Float, Float, Int) -> Self

pub struct Color {
  r : Float
  g : Float
  b : Float
  a : Float
}
pub fn Color::black() -> Self
pub fn Color::new(Float, Float, Float, Float) -> Self
pub fn Color::white() -> Self

pub struct ColorMaterial {
  handle : @asset.Handle[ColorMaterialAsset]
}
pub fn ColorMaterial::color(Self) -> Color
pub fn ColorMaterial::new(Color) -> Self

pub struct ColorMaterialAsset {
  color : Color
}
pub fn ColorMaterialAsset::new(Color) -> Self

pub struct Ellipse2dBuilder {
  id : Int
}
pub fn Ellipse2dBuilder::resolution(Self, Int) -> Self

pub(all) struct GizmoConfig {
  enabled : Bool
  line : GizmoLineConfig
  depth_bias : Float
  render_layers : RenderLayers
}
pub fn GizmoConfig::default() -> Self

pub(all) struct GizmoLineConfig {
  width : Float
  perspective : Bool
  style : GizmoLineStyle
  joints : GizmoLineJoint
}
pub fn GizmoLineConfig::default() -> Self

pub(all) enum GizmoLineJoint {
  None
  Miter
  Round(Int)
  Bevel
}

pub(all) enum GizmoLineStyle {
  Solid
  Dotted
  Dashed(gap_scale~ : Float, line_scale~ : Float)
}

pub struct Gizmos {
  layers : RenderLayers
}
pub fn Gizmos::arc_2d(Self, Isometry2d, Float, Float, Color) -> Arc2dBuilder
pub fn Gizmos::arrow_2d(Self, @math.Vec2, @math.Vec2, Color) -> ArrowBuilder
pub fn Gizmos::axes_2d(Self, Isometry2d, Float) -> Unit
pub fn Gizmos::circle_2d(Self, Isometry2d, Float, Color) -> Ellipse2dBuilder
pub fn Gizmos::cross_2d(Self, Isometry2d, Float, Color) -> Unit
pub fn Gizmos::curve_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::curve_gradient_2d(Self, Array[(@math.Vec2, Color)]) -> Unit
pub fn Gizmos::ellipse_2d(Self, Isometry2d, @math.Vec2, Color) -> Ellipse2dBuilder
pub fn Gizmos::grid_2d(Self, Isometry2d, @math.IVec2, @math.Vec2, Color) -> Grid2dBuilder
pub fn Gizmos::line_2d(Self, @math.Vec2, @math.Vec2, Color) -> Unit
pub fn Gizmos::line_gradient_2d(Self, @math.Vec2, @math.Vec2, Color, Color) -> Unit
pub fn Gizmos::lineloop_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::linestrip_2d(Self, Array[@math.Vec2], Color) -> Unit
pub fn Gizmos::linestrip_gradient_2d(Self, Array[(@math.Vec2, Color)]) -> Unit
pub fn Gizmos::long_arc_2d_between(Self, @math.Vec2, @math.Vec2, @math.Vec2, Color) -> Arc2dBuilder
pub fn Gizmos::new() -> Self
pub fn Gizmos::ray_2d(Self, @math.Vec2, @math.Vec2, Color) -> Unit
pub fn Gizmos::ray_gradient_2d(Self, @math.Vec2, @math.Vec2, Color, Color) -> Unit
pub fn Gizmos::rect_2d(Self, Isometry2d, @math.Vec2, Color) -> Unit
pub fn Gizmos::rounded_rect_2d(Self, Isometry2d, @math.Vec2, Color) -> RoundedRectBuilder
pub fn Gizmos::short_arc_2d_between(Self, @math.Vec2, @math.Vec2, @math.Vec2, Color) -> Arc2dBuilder
pub fn Gizmos::with_layers(Self, RenderLayers) -> Self
pub impl @app.SystemParam for Gizmos

pub struct GpuMesh2d {
  mesh_id : Int
}
pub fn GpuMesh2d::new(Int) -> Self

pub struct Grid2dBuilder {
  id : Int
}
pub fn Grid2dBuilder::outer_edges(Self) -> Self
pub fn Grid2dBuilder::outer_edges_x(Self) -> Self
pub fn Grid2dBuilder::outer_edges_y(Self) -> Self
pub fn Grid2dBuilder::skew(Self, @math.Vec2) -> Self
pub fn Grid2dBuilder::skew_x(Self, Float) -> Self
pub fn Grid2dBuilder::skew_y(Self, Float) -> Self

pub struct Isometry2d {
  translation : @math.Vec2
  rotation : Float
}
pub fn Isometry2d::identity() -> Self
pub fn Isometry2d::new(@math.Vec2, Float) -> Self
pub fn Isometry2d::transform_point(Self, @math.Vec2) -> @math.Vec2

pub struct Mesh2d {
  mesh : @asset.Handle[@mesh.Mesh]
}
pub fn Mesh2d::from_capsule(Capsule2d) -> Self
pub fn Mesh2d::from_geometry(@mesh.Mesh2dGeometry) -> Self
pub fn Mesh2d::from_rectangle(Rectangle) -> Self
pub fn Mesh2d::new(@asset.Handle[@mesh.Mesh]) -> Self

pub struct Mesh2dBundle {
  mesh : Mesh2d
  material : ColorMaterial
  transform : @math.Transform
  layers : RenderLayers
  visibility : @visibility.Visibility
  inherited_visibility : @visibility.InheritedVisibility
  view_visibility : @visibility.ViewVisibility
}
pub fn Mesh2dBundle::new(Mesh2d, ColorMaterial, @math.Transform) -> Self
pub fn Mesh2dBundle::new_with_layers(Mesh2d, ColorMaterial, @math.Transform, RenderLayers) -> Self
pub fn[W : @core.SpawnWorld + @core.ChangeTickWorld + Has_Mesh2d + Has_ColorMaterial + Has_GpuMesh2d + Has_RenderLayers + @math.Has_Transform + @visibility.Has_Visibility + @visibility.Has_InheritedVisibility + @visibility.Has_ViewVisibility] Mesh2dBundle::spawn(Self, W) -> @core.Entity

pub struct OrthographicProjection {
  scale : Float
}
pub fn OrthographicProjection::default_2d() -> Self
pub fn OrthographicProjection::new(Float) -> Self
pub fn OrthographicProjection::with_scale(Self, Float) -> Self

pub(all) enum Projection {
  Orthographic(OrthographicProjection)
}
pub fn Projection::orthographic_2d() -> Self

pub struct Rectangle {
  half_size : @math.Vec2
}
pub fn Rectangle::default() -> Self
pub fn Rectangle::from_size(@math.Vec2) -> Self
pub fn Rectangle::new(Float, Float) -> Self

pub struct RenderLayers {
  mask : Int
}
pub fn RenderLayers::default() -> Self
pub fn RenderLayers::layer(Int) -> Self
pub fn RenderLayers::matches(Self, Self) -> Bool

type RenderState

pub(all) enum RenderTarget {
  Screen
  Image(@asset.Handle[@asset.Image])
}

pub struct RoundedRectBuilder {
  id : Int
}
pub fn RoundedRectBuilder::arc_resolution(Self, Int) -> Self
pub fn RoundedRectBuilder::corner_radius(Self, Float) -> Self

pub struct Sprite {
  image : @asset.Handle[@asset.Image]
  texture_atlas : @asset.TextureAtlas?
  color : Color
  flip_x : Bool
  flip_y : Bool
  custom_size : @math.Vec2?
  rect : @math.Rect?
}
pub fn Sprite::from_atlas_image(@asset.Handle[@asset.Image], @asset.TextureAtlas) -> Self
pub fn Sprite::from_image(@asset.Handle[@asset.Image]) -> Self
pub fn Sprite::with_color(Self, Color) -> Self
pub fn Sprite::with_custom_size(Self, @math.Vec2?) -> Self
pub fn Sprite::with_flip_x(Self, Bool) -> Self
pub fn Sprite::with_flip_y(Self, Bool) -> Self
pub fn Sprite::with_rect(Self, @math.Rect?) -> Self
pub fn Sprite::with_texture_atlas(Self, @asset.TextureAtlas?) -> Self

pub struct SpriteBundle {
  sprite : Sprite
  anchor : Anchor
  transform : @math.Transform
  layers : RenderLayers
  visibility : @visibility.Visibility
  inherited_visibility : @visibility.InheritedVisibility
  view_visibility : @visibility.ViewVisibility
}
pub fn SpriteBundle::new(Sprite, @math.Transform) -> Self
pub fn SpriteBundle::new_with_layers(Sprite, @math.Transform, RenderLayers) -> Self
pub fn[W : @core.SpawnWorld + @core.ChangeTickWorld + Has_Sprite + Has_Anchor + Has_RenderLayers + @math.Has_Transform + @visibility.Has_Visibility + @visibility.Has_InheritedVisibility + @visibility.Has_ViewVisibility] SpriteBundle::spawn(Self, W) -> @core.Entity

pub struct Viewport {
  physical_position : @math.IVec2
  physical_size : @math.IVec2
}
pub fn Viewport::new(@math.IVec2, @math.IVec2) -> Self

// Type aliases

// Traits
pub(open) trait HasRes_RenderState {
  get_render_state_resource(Self) -> @core.Resource[RenderState]
}

pub(open) trait Has_Anchor {
  get_anchor_store(Self) -> @core.ComponentStore[Anchor]
}

pub(open) trait Has_Camera {
  get_camera_store(Self) -> @core.ComponentStore[Camera]
}

pub(open) trait Has_Camera2d {
  get_camera2d_store(Self) -> @core.ComponentStore[Camera2d]
}

pub(open) trait Has_ColorMaterial {
  get_color_material_store(Self) -> @core.ComponentStore[ColorMaterial]
}

pub(open) trait Has_GpuMesh2d {
  get_gpu_mesh2d_store(Self) -> @core.ComponentStore[GpuMesh2d]
}

pub(open) trait Has_Mesh2d {
  get_mesh2d_store(Self) -> @core.ComponentStore[Mesh2d]
}

pub(open) trait Has_Projection {
  get_projection_store(Self) -> @core.ComponentStore[Projection]
}

pub(open) trait Has_RenderLayers {
  get_render_layers_store(Self) -> @core.ComponentStore[RenderLayers]
}

pub(open) trait Has_RenderTarget {
  get_render_target_store(Self) -> @core.ComponentStore[RenderTarget]
}

pub(open) trait Has_Sprite {
  get_sprite_store(Self) -> @core.ComponentStore[Sprite]
}

