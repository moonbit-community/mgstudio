// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mgstudio/asset"

import {
  "Milky2018/mgstudio/app",
  "Milky2018/mgstudio/core",
  "Milky2018/mgstudio/math",
}

// Values
pub fn asset_add_texture_atlas_layout(TextureAtlasLayout) -> Handle[TextureAtlasLayout]

pub fn asset_copy_texture_to_texture(Handle[Image], @math.UVec2, Handle[Image]) -> Unit

pub fn asset_create_dynamic_texture(@math.UVec2, Bool) -> Handle[Image]

pub fn asset_font_read_bytes(Handle[Font]) -> Bytes?

pub fn asset_get_loaded_folder(Handle[LoadedFolder]) -> LoadedFolder?

pub fn asset_get_texture_atlas_layout(Handle[TextureAtlasLayout]) -> TextureAtlasLayout?

pub fn asset_is_texture_loaded(Handle[Image]) -> Bool

pub fn asset_loaded_folder_drain_events() -> Array[AssetEvent[LoadedFolder]]

pub fn[W] asset_plugin(@app.App[W]) -> @app.App[W]

pub fn[W] asset_plugin_nearest(@app.App[W]) -> @app.App[W]

pub fn asset_set_default_sampler_nearest(Bool) -> Unit

pub fn asset_set_texture_atlas_layout(Handle[TextureAtlasLayout], TextureAtlasLayout) -> Bool

pub fn asset_set_texture_sampler(Handle[Image], ImageSampler) -> Unit

pub fn[W] asset_system(W) -> Unit

pub fn asset_texture_height(Handle[Image]) -> Int

pub fn asset_texture_width(Handle[Image]) -> Int

pub fn asset_update_loaded_folders() -> Unit

pub fn asset_update_texture_region(Handle[Image], @math.URect, Int) -> Unit

pub fn asset_update_texture_region_rgba8(Handle[Image], @math.URect, Bytes) -> Unit

pub let ecs_components : Array[String]

pub let ecs_resources : Array[String]

pub fn host_asset_copy_texture_to_texture(Int, Int, Int, Int) -> Unit

pub fn host_asset_create_dynamic_texture(Int, Int, Bool) -> Int

pub fn host_asset_font_bytes_get(Int, Int) -> Int

pub fn host_asset_font_bytes_len(Int) -> Int

pub fn host_asset_is_texture_loaded(Int) -> Bool

pub fn host_asset_load_folder(String) -> Int

pub fn host_asset_load_font(String) -> Int

pub fn host_asset_load_texture(String, Bool) -> Int

pub fn host_asset_load_wgsl(String) -> Int

pub fn host_asset_loaded_folder_handles_get(Int, Int) -> Int

pub fn host_asset_loaded_folder_handles_len(Int) -> Int

pub fn host_asset_poll_loaded_folder_event_id() -> Int

pub fn host_asset_poll_loaded_folder_event_kind() -> Int

pub fn host_asset_set_texture_sampler(Int, Int) -> Unit

pub fn host_asset_texture_height(Int) -> Int

pub fn host_asset_texture_width(Int) -> Int

pub fn host_asset_update_texture_region(Int, Int, Int, Int, Int, Int) -> Unit

pub fn host_asset_update_texture_region_bytes(Int, Int, Int, Int, Int, Int) -> Unit

// Errors

// Types and methods
pub(all) enum AssetEvent[T] {
  Added(Handle[T])
  Modified(Handle[T])
  Removed(Handle[T])
  LoadedWithDependencies(Handle[T])
}

pub struct AssetId[T] {
  id : Int
  phantom : T?
}
pub fn[T] AssetId::index(Self[T]) -> Int
pub fn[T] AssetId::new(Int) -> Self[T]
pub impl[T : Eq] Eq for AssetId[T]
pub impl[T : Show] Show for AssetId[T]

pub struct AssetServer {
  paths : Array[String]
}
pub fn AssetServer::get_handle(Self, String) -> Handle[Image]?
pub fn AssetServer::load(Self, String) -> Handle[Image]
pub fn AssetServer::load_folder(Self, String) -> Handle[LoadedFolder]
pub fn AssetServer::load_font(Self, String) -> Handle[Font]
pub fn AssetServer::load_nearest(Self, String) -> Handle[Image]
pub fn AssetServer::load_wgsl(Self, String) -> Handle[Shader]
pub fn AssetServer::new() -> Self

pub struct Assets[T] {
  items : Array[T?]
  mut alive : Int
  events : Array[AssetEvent[T]]
}
pub fn[T] Assets::add(Self[T], T) -> Handle[T]
pub fn[T] Assets::contains(Self[T], Handle[T]) -> Bool
pub fn[T] Assets::drain_events(Self[T]) -> Array[AssetEvent[T]]
pub fn[T] Assets::get(Self[T], Handle[T]) -> T?
pub fn[T] Assets::insert(Self[T], Handle[T], T) -> Bool
pub fn[T] Assets::is_empty(Self[T]) -> Bool
pub fn[T] Assets::len(Self[T]) -> Int
pub fn[T] Assets::new() -> Self[T]
pub fn[T] Assets::remove(Self[T], Handle[T]) -> T?
pub fn[T] Assets::set(Self[T], Handle[T], T) -> Bool

pub struct DynamicTextureAtlasBuilder {
  size : @math.UVec2
  padding : Int
  free_rects : Array[@math.URect]
}
pub fn DynamicTextureAtlasBuilder::add_texture(Self, TextureAtlasLayout, @math.UVec2) -> (Int, @math.URect)?
pub fn DynamicTextureAtlasBuilder::new(@math.UVec2, Int) -> Self

pub(all) enum DynamicTextureAtlasBuilderError {
  FailedToAllocateSpace
}

pub struct Font {
}

pub struct Handle[T] {
  id : Int
  phantom : T?
}
pub fn[T] Handle::asset_id(Self[T]) -> AssetId[T]
pub fn[T] Handle::from_asset_id(AssetId[T]) -> Self[T]
pub fn[T] Handle::id(Self[T]) -> Int
pub fn[T] Handle::new(Int) -> Self[T]

pub struct Image {
  width : Int
  height : Int
  pixels : Bytes
}
pub fn Image::new(Int, Int, Bytes) -> Self

pub(all) enum ImageSampler {
  Linear
  Nearest
}

pub struct LoadedFolder {
  handles : Array[Handle[Image]]
}

pub struct Shader {
  source : String
}
pub fn Shader::new(String) -> Self

pub struct TextureAtlas {
  layout : Handle[TextureAtlasLayout]
  index : Int
}
pub fn TextureAtlas::new(Handle[TextureAtlasLayout], Int) -> Self
pub fn TextureAtlas::texture_rect(Self, Assets[TextureAtlasLayout]) -> @math.URect?
pub fn TextureAtlas::with_index(Self, Int) -> Self
pub fn TextureAtlas::with_layout(Self, Handle[TextureAtlasLayout]) -> Self

pub struct TextureAtlasBuilder {
  padding : @math.UVec2
  initial_size : @math.UVec2
  max_size : @math.UVec2
  nearest : Bool
  textures : Array[Handle[Image]]
}
pub fn TextureAtlasBuilder::add_texture(Self, Handle[Image]) -> Self
pub fn TextureAtlasBuilder::build(Self) -> (TextureAtlasLayout, TextureAtlasSources, Handle[Image])
pub fn TextureAtlasBuilder::default() -> Self
pub fn TextureAtlasBuilder::initial_size(Self, @math.UVec2) -> Self
pub fn TextureAtlasBuilder::max_size(Self, @math.UVec2) -> Self
pub fn TextureAtlasBuilder::padding(Self, @math.UVec2) -> Self
pub fn TextureAtlasBuilder::sampler_nearest(Self, Bool) -> Self
pub fn TextureAtlasBuilder::try_build(Self) -> (TextureAtlasLayout, TextureAtlasSources, Handle[Image])?

pub struct TextureAtlasLayout {
  size : @math.UVec2
  textures : Array[@math.URect]
}
pub fn TextureAtlasLayout::add_texture(Self, @math.URect) -> Int
pub fn TextureAtlasLayout::from_grid(@math.UVec2, Int, Int, padding? : @math.UVec2, offset? : @math.UVec2) -> Self
pub fn TextureAtlasLayout::is_empty(Self) -> Bool
pub fn TextureAtlasLayout::len(Self) -> Int
pub fn TextureAtlasLayout::new_empty(@math.UVec2) -> Self

pub struct TextureAtlasSources {
  texture_ids : Array[(Handle[Image], Int)]
}
pub fn TextureAtlasSources::handle(Self, Handle[TextureAtlasLayout], Handle[Image]) -> TextureAtlas?
pub fn TextureAtlasSources::texture_index(Self, Handle[Image]) -> Int?

// Type aliases

// Traits
pub(open) trait Has_TextureAtlas {
  get_texture_atlas_store(Self) -> @core.ComponentStore[TextureAtlas]
}

