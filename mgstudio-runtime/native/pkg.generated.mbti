// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mgstudio-runtime-native"

import {
  "Milky2018/mgstudio-runtime-core",
  "Milky2018/mgstudio-runtime-native/window",
  "Milky2018/wasmoon/jit",
  "Milky2018/wasmoon/runtime",
  "Milky2018/wasmoon/types",
  "Milky2018/wgpu_mbt",
}

// Values
pub fn add_mgstudio_host_imports(@runtime.Linker, HostContext) -> Unit

pub fn add_moonbit_ffi_imports(@runtime.Linker, HostContext) -> Unit

pub fn call_jit_func_by_index(@jit.JITModule, Int) -> Bool raise @jit.JITTrap

pub fn prepare_jit_for_instance(@types.Module, @runtime.ModuleInstance, @runtime.Store) -> @jit.JITModule raise NativeJitSetupError

pub fn run_game(String, String, String, wgpu_lib? : String) -> Unit raise

// Errors
pub(all) suberror NativeJitSetupError {
  UnsupportedModule(String)
  JitLoadFailed
  MemoryInitFailed
  GlobalsAllocFailed
  MissingCHeap
}
pub impl Show for NativeJitSetupError

pub(all) suberror NativeRuntimeError {
  InvalidWasmPath(String)
  ReadWasmFailed(String, String)
  ParseWasmFailed(String, String)
  InstantiateFailed(String, String)
  MissingExport(String)
  ExportCallFailed(String, String)
  JitSetupFailed(String)
  JitCallFailed(String, String)
}
pub impl Show for NativeRuntimeError

// Types and methods
pub struct GpuBackend {
  instance : @wgpu_mbt.Instance
  adapter : @wgpu_mbt.Adapter
  device : @wgpu_mbt.Device
  queue : @wgpu_mbt.Queue
  assets_base : String
  mut surface : @wgpu_mbt.Surface?
  mut surface_format : UInt
  mut configured_width : Int
  mut configured_height : Int
  mut frame : GpuFrameState?
  mut pass_state : GpuPassState?
  mut sprite_bgl_tex : @wgpu_mbt.BindGroupLayout?
  mut sprite_bgl_ubo : @wgpu_mbt.BindGroupLayout?
  mut sprite_pipeline_layout : @wgpu_mbt.PipelineLayout?
  mut sprite_pipeline : @wgpu_mbt.RenderPipeline?
  mut sprite_uniform_buf : @wgpu_mbt.Buffer?
  mut sprite_uniform_bg : @wgpu_mbt.BindGroup?
  mut mesh_bgl_color : @wgpu_mbt.BindGroupLayout?
  mut mesh_pipeline_layout : @wgpu_mbt.PipelineLayout?
  mut mesh_pipeline : @wgpu_mbt.RenderPipeline?
  mut mesh_color_buf : @wgpu_mbt.Buffer?
  mut mesh_color_bg : @wgpu_mbt.BindGroup?
  mut mesh_scratch_vb : @wgpu_mbt.Buffer?
  mut mesh_scratch_capacity : UInt64
  next_id : Ref[Int]
  textures : Ref[Array[GpuTextureInfo]]
  meshes : Ref[Array[GpuMeshInfo]]
}
pub fn GpuBackend::begin_frame(Self) -> Unit
pub fn GpuBackend::begin_pass(Self, Int, Int, Int, Float, Float, Float, Float, Float, Float, Float, Float, Int, Int, Int, Int) -> Unit
pub fn GpuBackend::configure_surface(Self, Int, Int) -> Unit
pub fn GpuBackend::create_mesh_capsule(Self, Float, Float, Int) -> Int
pub fn GpuBackend::create_mesh_rectangle(Self, Float, Float) -> Int
pub fn GpuBackend::create_mesh_triangles_xy(Self, Array[Float]) -> Int
pub fn GpuBackend::create_render_target(Self, Int, Int, Bool) -> Int
pub fn GpuBackend::create_surface(Self, @window.Window) -> Unit
pub fn GpuBackend::create_texture_rgba8(Self, Int, Int, Bytes, Bool) -> Int
pub fn GpuBackend::draw_mesh(Self, Int, Float, Float, Float, Float, Float, Float, Float, Float, Float) -> Unit
pub fn GpuBackend::draw_sprite_uv(Self, Int, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float) -> Unit
pub fn GpuBackend::end_frame(Self) -> Unit
pub fn GpuBackend::end_pass(Self) -> Unit
pub fn GpuBackend::ensure_surface_configured(Self, Int, Int) -> Unit
pub fn GpuBackend::is_texture_loaded(Self, Int) -> Bool
pub fn GpuBackend::new(assets_base? : String) -> Self
pub fn GpuBackend::set_texture_sampler(Self, Int, Int) -> Unit
pub fn GpuBackend::texture_height(Self, Int) -> Int
pub fn GpuBackend::texture_width(Self, Int) -> Int
pub fn GpuBackend::write_texture_region_rgba8(Self, Int, Int, Int, Int, Int, Bytes) -> Unit

pub struct GpuFrameState {
  surface_tex : @wgpu_mbt.SurfaceTexture
  surface_view : @wgpu_mbt.TextureView
  encoder : @wgpu_mbt.CommandEncoder
  mut pass : @wgpu_mbt.RenderPass?
}

pub struct GpuMeshInfo {
  id : Int
  vertices_xy : Array[Float]
  indices_u16 : Array[Int]
  index_count : UInt
  index_buf : @wgpu_mbt.Buffer
}

pub struct GpuPassState {
  target_id : Int
  width_logical : Float
  height_logical : Float
  camera_x : Float
  camera_y : Float
  camera_rot : Float
  camera_scale : Float
  viewport_x : UInt
  viewport_y : UInt
  viewport_w : UInt
  viewport_h : UInt
}

pub struct GpuTextureInfo {
  id : Int
  width : Int
  height : Int
  texture : @wgpu_mbt.Texture
  view : @wgpu_mbt.TextureView
  sampler : @wgpu_mbt.Sampler
  bind_group : @wgpu_mbt.BindGroup
}

pub struct HostContext {
  mut store : @runtime.Store?
  mut instance : @runtime.ModuleInstance?
  mut jit : @jit.JITModule?
  mut gpu : GpuBackend?
  mut window : @window.Window?
  assets_source : @mgstudio-runtime-core.SourceSpec
  data_source : @mgstudio-runtime-core.SourceSpec
  string_sink : Ref[Array[Char]]
  next_string_id : Ref[Int]
  strings : Ref[Array[(Int, String)]]
  bytes_sink : Ref[Array[Byte]]
  next_bytes_id : Ref[Int]
  bytes : Ref[Array[(Int, Bytes)]]
  next_font_id : Ref[Int]
  fonts : Ref[Array[(Int, Bytes)]]
  next_shader_id : Ref[Int]
  shaders : Ref[Array[(Int, String)]]
  next_closure_id : Ref[Int]
  closures : Ref[Array[(Int, @types.Value, Int)]]
}
pub fn HostContext::new(String, String) -> Self raise

pub struct SpriteUniformPack {
  center_ndc_x : Float
  center_ndc_y : Float
  half_view_x : Float
  half_view_y : Float
  rot : Float
  inv_half_w : Float
  inv_half_h : Float
  uv_min_x : Float
  uv_min_y : Float
  uv_max_x : Float
  uv_max_y : Float
  color_r : Float
  color_g : Float
  color_b : Float
  color_a : Float
}

// Type aliases

// Traits

