// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mgstudio-runtime-native"

import {
  "Milky2018/mgstudio-runtime-core",
  "Milky2018/mgstudio-runtime-native/window",
  "Milky2018/wasmoon/jit",
  "Milky2018/wasmoon/runtime",
  "Milky2018/wasmoon/types",
  "Milky2018/wgpu_mbt",
}

// Values
pub fn add_mgstudio_host_imports(@runtime.Linker, HostContext) -> Unit

pub fn add_moonbit_ffi_imports(@runtime.Linker, HostContext) -> Unit

pub fn call_jit_func_by_index(@jit.JITModule, Int) -> Bool raise @jit.JITTrap

pub fn prepare_jit_for_instance(@types.Module, @runtime.ModuleInstance, @runtime.Store) -> PreparedJit raise NativeJitSetupError

pub fn run_game(String, String, String, wgpu_lib? : String) -> Unit raise

// Errors
pub(all) suberror GpuBackendError {
  Fatal(String)
}
pub impl Show for GpuBackendError

pub(all) suberror NativeJitSetupError {
  UnsupportedModule(String)
  JitLoadFailed
  MemoryInitFailed
  GlobalsAllocFailed
  MissingJitTable(Int)
  MissingCHeap
}
pub impl Show for NativeJitSetupError

pub(all) suberror NativeRuntimeError {
  InvalidWasmPath(String)
  ReadWasmFailed(String, String)
  ParseWasmFailed(String, String)
  InstantiateFailed(String, String)
  MissingExport(String)
  ExportCallFailed(String, String)
  JitSetupFailed(String)
  JitCallFailed(String, String)
}
pub impl Show for NativeRuntimeError

// Types and methods
pub struct GpuBackend {
  instance : @wgpu_mbt.Instance
  adapter : @wgpu_mbt.Adapter
  device : @wgpu_mbt.Device
  queue : @wgpu_mbt.Queue
  assets_base : String
  mut surface : @wgpu_mbt.Surface?
  mut surface_format : @wgpu_mbt.TextureFormat?
  mut configured_width : Int
  mut configured_height : Int
  mut frame : GpuFrameState?
  mut pass_state : GpuPassState?
  mut sprite_bgl_tex : @wgpu_mbt.BindGroupLayout?
  mut sprite_bgl_globals : @wgpu_mbt.BindGroupLayout?
  mut sprite_pipeline_layout : @wgpu_mbt.PipelineLayout?
  mut sprite_pipeline : @wgpu_mbt.RenderPipeline?
  mut sprite_pipeline_surface : @wgpu_mbt.RenderPipeline?
  mut sprite_pipeline_surface_format : @wgpu_mbt.TextureFormat?
  mut sprite_globals_buf : @wgpu_mbt.Buffer?
  mut sprite_instance_buf : @wgpu_mbt.Buffer?
  mut sprite_instance_capacity : UInt64
  mut sprite_globals_bg : @wgpu_mbt.BindGroup?
  sprite_instance_data : Array[Float]
  sprite_batches : Array[SpriteBatch]
  mut sprite_instance_count : UInt
  mut ui_pipeline : @wgpu_mbt.RenderPipeline?
  mut ui_pipeline_surface : @wgpu_mbt.RenderPipeline?
  mut ui_pipeline_surface_format : @wgpu_mbt.TextureFormat?
  mut ui_instance_buf : @wgpu_mbt.Buffer?
  mut ui_instance_capacity : UInt64
  mut ui_globals_bg : @wgpu_mbt.BindGroup?
  ui_instance_data : Array[Float]
  ui_batches : Array[UiBatch]
  mut ui_instance_count : UInt
  mut ui_shadow_pipeline : @wgpu_mbt.RenderPipeline?
  mut ui_shadow_pipeline_surface : @wgpu_mbt.RenderPipeline?
  mut ui_shadow_pipeline_surface_format : @wgpu_mbt.TextureFormat?
  mut ui_shadow_instance_buf : @wgpu_mbt.Buffer?
  mut ui_shadow_instance_capacity : UInt64
  mut ui_shadow_globals_bg : @wgpu_mbt.BindGroup?
  ui_shadow_instance_data : Array[Float]
  ui_shadow_batches : Array[UiBatch]
  mut ui_shadow_instance_count : UInt
  mut mesh_bgl_uniform : @wgpu_mbt.BindGroupLayout?
  mut mesh_pipeline_layout : @wgpu_mbt.PipelineLayout?
  mut mesh_pipeline : @wgpu_mbt.RenderPipeline?
  mut mesh_uniform_buf : @wgpu_mbt.Buffer?
  mut mesh_uniform_bg : @wgpu_mbt.BindGroup?
  next_id : Ref[Int]
  textures : Ref[Array[GpuTextureInfo]]
  meshes : Ref[Array[GpuMeshInfo]]
}
pub fn GpuBackend::begin_frame(Self) -> Unit
pub fn GpuBackend::begin_pass(Self, Int, Int, Int, Float, Float, Float, Float, Float, Float, Float, Float, Int, Int, Int, Int) -> Unit raise GpuBackendError
pub fn GpuBackend::clear_scissor(Self) -> Unit raise GpuBackendError
pub fn GpuBackend::configure_surface(Self, Int, Int) -> Unit
pub fn GpuBackend::create_mesh_capsule(Self, Float, Float, Int) -> Int
pub fn GpuBackend::create_mesh_rectangle(Self, Float, Float) -> Int
pub fn GpuBackend::create_mesh_triangles_xy(Self, Array[Float]) -> Int
pub fn GpuBackend::create_render_target(Self, Int, Int, Bool) -> Int raise GpuBackendError
pub fn GpuBackend::create_surface(Self, @window.Window) -> Unit
pub fn GpuBackend::create_texture_rgba8(Self, Int, Int, Bytes, Bool) -> Int raise GpuBackendError
pub fn GpuBackend::draw_mesh(Self, Int, Float, Float, Float, Float, Float, Float, Float, Float, Float) -> Unit raise GpuBackendError
pub fn GpuBackend::draw_sprite_uv(Self, Int, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float) -> Unit raise GpuBackendError
pub fn GpuBackend::draw_ui_box_shadow(Self, Int, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Int) -> Unit raise GpuBackendError
pub fn GpuBackend::draw_ui_rect(Self, Int, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Int, Float, Float, Float, Float, Float, Float, Float, Float) -> Unit raise GpuBackendError
pub fn GpuBackend::end_frame(Self) -> Unit raise GpuBackendError
pub fn GpuBackend::end_pass(Self) -> Unit raise GpuBackendError
pub fn GpuBackend::ensure_surface_configured(Self, Int, Int) -> Unit
pub fn GpuBackend::is_texture_loaded(Self, Int) -> Bool
pub fn GpuBackend::new(assets_base? : String) -> Self
pub fn GpuBackend::set_scissor(Self, Int, Int, Int, Int) -> Unit raise GpuBackendError
pub fn GpuBackend::set_texture_sampler(Self, Int, Int) -> Unit raise GpuBackendError
pub fn GpuBackend::texture_height(Self, Int) -> Int
pub fn GpuBackend::texture_width(Self, Int) -> Int
pub fn GpuBackend::write_texture_region_rgba8(Self, Int, Int, Int, Int, Int, Bytes) -> Unit

pub struct GpuFrameState {
  surface_tex : @wgpu_mbt.SurfaceTexture
  surface_view : @wgpu_mbt.TextureView
  encoder : @wgpu_mbt.CommandEncoder
  mut pass : @wgpu_mbt.RenderPass?
}

pub struct GpuMeshInfo {
  id : Int
  index_count : UInt
  vertex_count : UInt
  vertex_buf : @wgpu_mbt.Buffer
  index_buf : @wgpu_mbt.Buffer
}

pub struct GpuPassState {
  target_id : Int
  width_logical : Float
  height_logical : Float
  camera_x : Float
  camera_y : Float
  camera_rot : Float
  camera_scale : Float
  viewport_x : UInt
  viewport_y : UInt
  viewport_w : UInt
  viewport_h : UInt
}

pub struct GpuTextureInfo {
  id : Int
  width : Int
  height : Int
  texture : @wgpu_mbt.Texture
  view : @wgpu_mbt.TextureView
  sampler : @wgpu_mbt.Sampler
  bind_group : @wgpu_mbt.BindGroup
}

pub struct HostContext {
  mut store : @runtime.Store?
  mut instance : @runtime.ModuleInstance?
  mut jit : @jit.JITModule?
  mut jit_globals_ptr : Int64
  mut gpu : GpuBackend?
  mut window : @window.Window?
  assets_source : @mgstudio-runtime-core.SourceSpec
  data_source : @mgstudio-runtime-core.SourceSpec
  string_sink : Ref[Array[Char]]
  next_string_id : Ref[Int]
  strings : Ref[Array[(Int, String)]]
  bytes_sink : Ref[Array[Byte]]
  next_bytes_id : Ref[Int]
  bytes : Ref[Array[(Int, Bytes)]]
  next_font_id : Ref[Int]
  fonts : Ref[Array[(Int, Bytes)]]
  next_shader_id : Ref[Int]
  shaders : Ref[Array[(Int, String)]]
  next_folder_id : Ref[Int]
  folders : Ref[Array[(Int, Array[Int])]]
  folder_events : Ref[Array[Int]]
  folder_events_pos : Ref[Int]
  next_closure_id : Ref[Int]
  closures : Ref[Array[(Int, @types.Value, Int)]]
}
pub fn HostContext::new(String, String) -> Self raise

pub struct PreparedJit {
  jm : @jit.JITModule
  globals_ptr : Int64
}

pub struct SpriteBatch {
  texture_id : Int
  first_instance : UInt
  mut instance_count : UInt
}

pub struct UiBatch {
  texture_id : Int
  first_instance : UInt
  mut instance_count : UInt
}

// Type aliases

// Traits

