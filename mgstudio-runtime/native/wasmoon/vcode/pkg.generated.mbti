// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/vcode"

import {
  "Milky2018/wasmoon/vcode/abi",
  "Milky2018/wasmoon/vcode/block",
  "Milky2018/wasmoon/vcode/emit",
  "Milky2018/wasmoon/vcode/instr",
  "Milky2018/wasmoon/vcode/regalloc",
}

// Values
pub fn dump_regalloc(String, @regalloc.LivenessResult, @regalloc.RegAllocResult) -> Unit

pub fn dump_vcode(@regalloc.VCodeFunction, String) -> Unit

// Errors

// Types and methods
type AArch64
pub fn AArch64::new() -> Self
pub impl TargetISA for AArch64

type AArch64Regs
pub fn AArch64Regs::d0(Self) -> @abi.PReg
pub fn AArch64Regs::d1(Self) -> @abi.PReg
pub fn AArch64Regs::d2(Self) -> @abi.PReg
pub fn AArch64Regs::d3(Self) -> @abi.PReg
pub fn AArch64Regs::d4(Self) -> @abi.PReg
pub fn AArch64Regs::d5(Self) -> @abi.PReg
pub fn AArch64Regs::d6(Self) -> @abi.PReg
pub fn AArch64Regs::d7(Self) -> @abi.PReg
pub fn AArch64Regs::fp(Self) -> @abi.PReg
pub fn AArch64Regs::lr(Self) -> @abi.PReg
pub fn AArch64Regs::new() -> Self
pub fn AArch64Regs::x0(Self) -> @abi.PReg
pub fn AArch64Regs::x1(Self) -> @abi.PReg
pub fn AArch64Regs::x2(Self) -> @abi.PReg
pub fn AArch64Regs::x3(Self) -> @abi.PReg
pub fn AArch64Regs::x4(Self) -> @abi.PReg
pub fn AArch64Regs::x5(Self) -> @abi.PReg
pub fn AArch64Regs::x6(Self) -> @abi.PReg
pub fn AArch64Regs::x7(Self) -> @abi.PReg

type CodeCache
pub fn CodeCache::clear(Self) -> Unit
pub fn CodeCache::contains(Self, Int) -> Bool
pub fn CodeCache::get(Self, Int) -> CompiledFunction?
pub fn CodeCache::insert(Self, Int, CompiledFunction) -> Unit
pub fn CodeCache::invalidate(Self, Int) -> Unit
pub fn CodeCache::new(Int) -> Self
pub fn CodeCache::remove(Self, Int) -> Unit
pub fn CodeCache::stats(Self) -> (Int, Int, Int, Int)
pub impl Show for CodeCache

pub struct CompiledFunction {
  name : String
  code : @emit.MachineCode
  entry_offset : Int
  code_size : Int
  frame_size : Int
  mut valid : Bool
}
pub fn CompiledFunction::get_call_fixups(Self) -> Array[@emit.CallFixup]
pub fn CompiledFunction::get_code(Self) -> Array[Int]
pub fn CompiledFunction::get_func_addr_fixups(Self) -> Array[@emit.FuncAddrFixup]
pub fn CompiledFunction::invalidate(Self) -> Unit
pub fn CompiledFunction::is_valid(Self) -> Bool
pub fn CompiledFunction::new(String, @emit.MachineCode, Int) -> Self
pub impl Show for CompiledFunction

type ExecutableRegion
pub fn ExecutableRegion::address_at(Self, Int) -> Int
pub fn ExecutableRegion::finalize(Self) -> Unit
pub fn ExecutableRegion::new(Int, Int) -> Self
pub fn ExecutableRegion::read_at(Self, Int, Int) -> Array[Int]
pub fn ExecutableRegion::remaining(Self) -> Int
pub fn ExecutableRegion::write(Self, Array[Int]) -> Result[Int, String]
pub impl Show for ExecutableRegion

pub struct GcCompilerConfig {
  needs_write_barriers : Bool
  needs_read_barriers : Bool
  needs_safepoints : Bool
  can_inline_alloc : Bool
  object_header_size : Int
}
pub impl Show for GcCompilerConfig

pub struct GcSafepoint {
  code_offset : Int
  live_refs : Array[Int]
  metadata : Int64
}
pub impl Show for GcSafepoint

type JITRuntime
pub fn JITRuntime::clear(Self) -> Unit
pub fn JITRuntime::invalidate(Self, Int) -> Unit
pub fn JITRuntime::lookup(Self, Int) -> CompiledFunction?
pub fn JITRuntime::new(Int, Int) -> Self
pub fn JITRuntime::register(Self, Int, CompiledFunction) -> Result[Int, String]
pub fn JITRuntime::stats(Self) -> (Int, Int, Int, Int, Int, Int, Int)
pub impl Show for JITRuntime

type MemoryManager
pub fn MemoryManager::alloc_region(Self, Int) -> ExecutableRegion
pub fn MemoryManager::finalize_all(Self) -> Unit
pub fn MemoryManager::get_current_region(Self) -> ExecutableRegion
pub fn MemoryManager::new(Int) -> Self
pub fn MemoryManager::total_allocated(Self) -> Int
pub fn MemoryManager::total_used(Self) -> Int
pub fn MemoryManager::write_code(Self, @emit.MachineCode) -> Result[(ExecutableRegion, Int), String]
pub impl Show for MemoryManager

pub struct NoBarrierGcCompiler {
  safepoints : Array[GcSafepoint]
}
pub fn NoBarrierGcCompiler::new() -> Self
pub impl GcCompiler for NoBarrierGcCompiler

pub enum PlatformABI {
  SystemV_AMD64
  Windows_x64
  AAPCS64
  Apple_ARM64
}
pub fn PlatformABI::current() -> Self
pub fn PlatformABI::float_arg_regs(Self) -> Int
pub fn PlatformABI::int_arg_regs(Self) -> Int
pub fn PlatformABI::requires_16_byte_stack_align(Self) -> Bool
pub impl Show for PlatformABI

type VCodeBuilder
pub fn VCodeBuilder::add(Self, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg
pub fn VCodeBuilder::add_param(Self, @abi.RegClass) -> @abi.VReg
pub fn VCodeBuilder::add_result(Self, @abi.RegClass) -> Unit
pub fn VCodeBuilder::ashr(Self, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg
pub fn VCodeBuilder::band(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::bor(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::branch(Self, @abi.VReg, @block.VCodeBlock, @block.VCodeBlock) -> Unit
pub fn VCodeBuilder::bxor(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::cmp(Self, @instr.CmpKind, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg
pub fn VCodeBuilder::create_block(Self) -> @block.VCodeBlock
pub fn VCodeBuilder::current_block(Self) -> @block.VCodeBlock?
pub fn VCodeBuilder::fadd(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::fcmp(Self, @instr.FCmpKind, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::fconst(Self, Double) -> @abi.VReg
pub fn VCodeBuilder::fdiv(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::fmul(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::fsub(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::get_function(Self) -> @regalloc.VCodeFunction
pub fn VCodeBuilder::iconst(Self, Int64) -> @abi.VReg
pub fn VCodeBuilder::jump(Self, @block.VCodeBlock, args? : Array[@abi.VReg]) -> Unit
pub fn VCodeBuilder::load(Self, @instr.MemType, @abi.VReg, Int) -> @abi.VReg
pub fn VCodeBuilder::lshr(Self, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg
pub fn VCodeBuilder::mov(Self, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::mul(Self, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg
pub fn VCodeBuilder::new(String) -> Self
pub fn VCodeBuilder::print(Self) -> String
pub fn VCodeBuilder::return_(Self, Array[@abi.VReg]) -> Unit
pub fn VCodeBuilder::sdiv(Self, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg
pub fn VCodeBuilder::shl(Self, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg
pub fn VCodeBuilder::store(Self, @instr.MemType, @abi.VReg, @abi.VReg, Int) -> Unit
pub fn VCodeBuilder::sub(Self, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg
pub fn VCodeBuilder::switch_to_block(Self, @block.VCodeBlock) -> Unit
pub fn VCodeBuilder::trap(Self, String) -> Unit
pub fn VCodeBuilder::udiv(Self, @abi.VReg, @abi.VReg, is_64? : Bool) -> @abi.VReg

// Type aliases

// Traits
pub(open) trait GcCompiler {
  config(Self) -> GcCompilerConfig
  gen_alloc_struct(Self, @regalloc.VCodeFunction, @block.VCodeBlock, Int, Array[@abi.VReg]) -> @abi.VReg
  gen_alloc_array(Self, @regalloc.VCodeFunction, @block.VCodeBlock, Int, @abi.VReg, @abi.VReg?) -> @abi.VReg
  gen_write_barrier_pre(Self, @regalloc.VCodeFunction, @abi.VReg, Int, @abi.VReg, @abi.VReg) -> Unit
  gen_write_barrier_post(Self, @regalloc.VCodeFunction, @abi.VReg, @abi.VReg) -> Unit
  gen_read_barrier(Self, @regalloc.VCodeFunction, @abi.VReg) -> @abi.VReg
  gen_safepoint_poll(Self, @regalloc.VCodeFunction) -> Unit
  record_safepoint(Self, Int, Array[@abi.VReg]) -> Unit
  get_safepoints(Self) -> Array[GcSafepoint]
  clear_safepoints(Self) -> Unit
}

pub(open) trait TargetISA {
  name(Self) -> String
  gpr_count(Self) -> Int
  fpr_count(Self) -> Int
  get_preg(Self, @abi.RegClass, Int) -> @abi.PReg?
  pointer_size(Self) -> Int
}

