// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/vcode/regalloc"

import {
  "Milky2018/wasmoon/ir",
  "Milky2018/wasmoon/vcode/abi",
  "Milky2018/wasmoon/vcode/block",
  "Milky2018/wasmoon/vcode/instr",
  "moonbitlang/core/set",
}

// Values
pub fn allocate_backtracking(VCodeFunction, LivenessResult, Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg]) -> RegAllocResult

pub fn allocate_registers_backtracking(VCodeFunction, settings? : @abi.ABISettings) -> VCodeFunction

pub fn apply_allocation(VCodeFunction, RegAllocResult) -> VCodeFunction

pub fn build_bundles_with_merging(VCodeFunction, LiveRangeSet) -> BundleSet

pub fn build_initial_bundles(LiveRangeSet) -> BundleSet

pub fn build_live_ranges(VCodeFunction, LivenessResult) -> LiveRangeSet

pub fn build_stack_layout_aarch64(RegAllocResult, VCodeFunction) -> AArch64StackFrame

pub fn compute_liveness(VCodeFunction) -> LivenessResult

pub fn compute_loop_depths(VCodeFunction) -> Array[Int]

pub fn compute_spill_weight(Bundle, LiveRangeSet, Array[Int]) -> Double

pub fn debug_liveness(LivenessResult) -> String

pub fn eliminate_dead_code(VCodeFunction) -> VCodeFunction

pub fn get_alloc_stats(VCodeFunction, settings? : @abi.ABISettings) -> AllocStats

pub fn process_constraints(VCodeFunction, RegAllocResult) -> Unit

pub fn verify_allocation_aarch64(VCodeFunction, LivenessResult, RegAllocResult, settings? : @abi.ABISettings) -> Unit

// Errors

// Types and methods
type AArch64StackFrame
pub fn AArch64StackFrame::alloc_spill(Self, @abi.VReg) -> Int
pub fn AArch64StackFrame::finalize(Self) -> Unit
pub fn AArch64StackFrame::gen_epilogue(Self) -> Array[@instr.VCodeInst]
pub fn AArch64StackFrame::gen_prologue(Self) -> Array[@instr.VCodeInst]
pub fn AArch64StackFrame::new() -> Self
pub fn AArch64StackFrame::save_callee_reg(Self, @abi.PReg) -> Int
pub fn AArch64StackFrame::setup(Self) -> Unit
pub fn AArch64StackFrame::size(Self) -> Int
pub impl Show for AArch64StackFrame

type AllocStats
pub impl Show for AllocStats

pub enum Allocation {
  Reg(@abi.PReg)
  Spill(Int)
  Unallocated
}
pub impl Show for Allocation

type BacktrackingAllocator
pub fn BacktrackingAllocator::allocate(Self) -> Unit
pub fn BacktrackingAllocator::generate_result(Self) -> RegAllocResult
pub fn BacktrackingAllocator::new(VCodeFunction, LiveRangeSet, BundleSet, Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg]) -> Self

type Bundle
pub fn Bundle::contains_range(Self, Int) -> Bool
pub fn Bundle::crosses_c_call(Self, LiveRangeSet) -> Bool
pub fn Bundle::crosses_call(Self, LiveRangeSet) -> Bool
pub fn Bundle::crosses_wasm_call(Self, LiveRangeSet) -> Bool
pub fn Bundle::get_fixed_reg(Self, LiveRangeSet) -> @abi.PReg?
pub fn Bundle::has_fixed_constraint(Self, LiveRangeSet) -> Bool
pub fn Bundle::new(Int, @abi.RegClass) -> Self
pub fn Bundle::overlaps(Self, Self, LiveRangeSet) -> Bool
pub fn Bundle::to_string(Self, LiveRangeSet) -> String
pub fn Bundle::total_length(Self, LiveRangeSet) -> Int

type BundleSet
pub fn BundleSet::get(Self, Int) -> Bundle
pub fn BundleSet::length(Self) -> Int
pub fn BundleSet::new() -> Self

type InstEdits

pub struct LiveInterval {
  vreg : @abi.VReg
  start : ProgPoint
  mut end : ProgPoint
  uses : Array[ProgPoint]
  hint : @abi.PReg?
  assigned : @abi.PReg?
  spill_slot : Int?
  mut crosses_call : Bool
  mut crosses_c_call : Bool
}
pub impl Show for LiveInterval

type LiveRange
pub fn LiveRange::end(Self, FixedArray[Int]) -> ProgPoint?
pub fn LiveRange::get_fixed_reg(Self) -> @abi.PReg?
pub fn LiveRange::has_fixed_constraint(Self) -> Bool
pub fn LiveRange::new(Int, @abi.VReg) -> Self
pub fn LiveRange::overlaps(Self, Self, FixedArray[Int]) -> Bool
pub fn LiveRange::start(Self, FixedArray[Int]) -> ProgPoint?
pub fn LiveRange::total_length(Self) -> Int
pub impl Show for LiveRange

type LiveRangeSet
pub fn LiveRangeSet::get(Self, Int) -> LiveRange
pub fn LiveRangeSet::get_by_vreg(Self, Int) -> LiveRange?
pub fn LiveRangeSet::length(Self) -> Int

pub struct LivenessResult {
  intervals : Map[Int, LiveInterval]
  use_def : Map[Int, UseDefInfo]
  live_in : Array[@set.Set[Int]]
  live_out : Array[@set.Set[Int]]
  block_order : FixedArray[Int]
  call_points : Array[(ProgPoint, @instr.CallConv)]
}

pub enum OperandConstraint {
  AnyReg
  FixedReg(@abi.PReg)
}
pub impl Show for OperandConstraint

type ProgPoint
pub impl Eq for ProgPoint
pub impl Show for ProgPoint

type ProgPointRange
pub fn ProgPointRange::contains(Self, ProgPoint, FixedArray[Int]) -> Bool
pub impl Show for ProgPointRange

pub enum ProgPos {
  Before
  After
}
pub impl Eq for ProgPos

type QueueEntry
pub impl Eq for QueueEntry

pub struct RegAllocResult {
  assignments : Map[Int, @abi.PReg]
  spill_slots : Map[Int, Int]
  num_spill_slots : Int
  inst_edits : Map[(Int, Int), InstEdits]
}

type RegMove
pub impl Show for RegMove

type SpillBundle
pub fn SpillBundle::new(Int, Int) -> Self

type StackFrame
pub fn StackFrame::add_callee_saved(Self, @abi.PReg) -> Int
pub fn StackFrame::alloc_local(Self, Int, Int, Int) -> Int
pub fn StackFrame::alloc_outgoing_arg(Self, Int, Int, Int) -> Int
pub fn StackFrame::alloc_spill_slot(Self, @abi.VReg, Int, Int) -> Int
pub fn StackFrame::finalize(Self) -> Unit
pub fn StackFrame::get_callee_saved(Self) -> Array[@abi.PReg]
pub fn StackFrame::new(Int) -> Self
pub fn StackFrame::print(Self) -> String
pub fn StackFrame::size(Self) -> Int
pub impl Show for StackFrame

type StackSlot
pub impl Show for StackSlot

pub enum StackSlotKind {
  Spill(@abi.VReg)
  Local(Int)
  OutgoingArg(Int)
  CalleeSaved(@abi.PReg)
}
pub impl Show for StackSlotKind

type UnionFind
pub fn UnionFind::find(Self, Int) -> Int
pub fn UnionFind::get_all_sets(Self) -> Array[Array[Int]]
pub fn UnionFind::get_set(Self, Int) -> Array[Int]
pub fn UnionFind::length(Self) -> Int
pub fn UnionFind::new(Int) -> Self
pub fn UnionFind::num_sets(Self) -> Int
pub fn UnionFind::same_set(Self, Int, Int) -> Bool
pub fn UnionFind::union(Self, Int, Int) -> Bool

type UseDefInfo

type UseKind
pub impl Show for UseKind

type UsePosition
pub impl Show for UsePosition

pub struct VCodeFunction {
  name : String
  params : Array[@abi.VReg]
  results : Array[@abi.RegClass]
  result_types : Array[@ir.Type]
  blocks : Array[@block.VCodeBlock]
  mut next_vreg_id : Int
  mut num_spill_slots : Int
  param_pregs : Array[@abi.PReg?]
  mut int_stack_params : Int
  mut max_outgoing_args_size : Int
}
pub fn VCodeFunction::add_param(Self, @abi.RegClass) -> @abi.VReg
pub fn VCodeFunction::add_param_preg(Self, @abi.PReg?) -> Unit
pub fn VCodeFunction::add_result(Self, @abi.RegClass) -> Unit
pub fn VCodeFunction::add_result_type(Self, @ir.Type) -> Unit
pub fn VCodeFunction::calls_multi_value_function(Self) -> Bool
pub fn VCodeFunction::clone_base(Self) -> Self
pub fn VCodeFunction::get_blocks(Self) -> Array[@block.VCodeBlock]
pub fn VCodeFunction::get_max_outgoing_args_size(Self) -> Int
pub fn VCodeFunction::get_name(Self) -> String
pub fn VCodeFunction::get_num_spill_slots(Self) -> Int
pub fn VCodeFunction::get_param_pregs(Self) -> Array[@abi.PReg?]
pub fn VCodeFunction::get_params(Self) -> Array[@abi.VReg]
pub fn VCodeFunction::get_result_types(Self) -> Array[@ir.Type]
pub fn VCodeFunction::needs_extra_results_ptr(Self) -> Bool
pub fn VCodeFunction::new(String) -> Self
pub fn VCodeFunction::new_block(Self) -> @block.VCodeBlock
pub fn VCodeFunction::new_vreg(Self, @abi.RegClass) -> @abi.VReg
pub fn VCodeFunction::print(Self) -> String
pub fn VCodeFunction::push_param(Self, @abi.VReg) -> Unit
pub fn VCodeFunction::set_int_stack_params(Self, Int) -> Unit
pub fn VCodeFunction::set_num_spill_slots(Self, Int) -> Unit
pub fn VCodeFunction::update_max_outgoing_args_size(Self, Int) -> Unit
pub fn VCodeFunction::uses_func_table(Self) -> Bool
pub fn VCodeFunction::uses_mem0(Self) -> Bool
pub impl Show for VCodeFunction

// Type aliases

// Traits

