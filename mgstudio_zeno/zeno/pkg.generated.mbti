// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_zeno/zeno"

// Values
pub fn apply(&PathData, Style, Transform?, &PathBuilder) -> Fill

pub fn arc(&PathBuilder, Vector, Double, Double, Double, ArcSize, ArcSweep, Vector) -> Unit

pub fn bounds(&PathData, Style, Transform?) -> Bounds

pub fn normal(Vector, Vector) -> Vector

pub fn segments(Iter[Command], Bool) -> Segments

pub fn stroke_into(Iter[Command], Stroke, &PathBuilder) -> Unit

pub fn stroke_with_storage(Iter[Command], Stroke, &PathBuilder, Array[Segment]) -> Unit

pub fn validate_svg(String) -> Result[Unit, Int]

// Errors

// Types and methods
pub struct Arc {
  mut count : Int
  center : (Double, Double)
  radii : (Double, Double)
  cosphi : Double
  sinphi : Double
  mut ang1 : Double
  ang2 : Double
  a : Double
}
pub fn Arc::default() -> Self
pub fn Arc::new(Vector, Double, Double, Double, ArcSize, ArcSweep, Vector) -> Self
pub fn Arc::next(Self) -> Command?

pub(all) enum ArcSize {
  Small
  Large
}

pub(all) enum ArcSweep {
  Negative
  Positive
}

pub struct Bounds {
  mut min : Vector
  mut max : Vector
  mut empty : Bool
}
pub fn Bounds::add_point(Self, Vector) -> Unit
pub fn Bounds::from_points(Array[Vector]) -> Self
pub fn Bounds::height(Self) -> Double
pub fn Bounds::is_empty(Self) -> Bool
pub fn Bounds::new(Vector, Vector) -> Self
pub fn Bounds::width(Self) -> Double

pub struct BoundsBuilder {
  mut count : Int
  mut min : Vector
  mut max : Vector
}
pub fn BoundsBuilder::new() -> Self
pub impl PathBuilder for BoundsBuilder

pub(all) enum Cap {
  Butt
  Square
  Round
}

pub struct Cell {
  x : Int
  mut cover : Int
  mut area : Int
  mut next : Int
}

pub(all) enum Command {
  MoveTo(Vector)
  LineTo(Vector)
  QuadTo(Vector, Vector)
  CurveTo(Vector, Vector, Vector)
  Close
}
pub fn Command::transform(Self, Transform) -> Self

pub struct Curve {
  a : Vector
  b : Vector
  c : Vector
  d : Vector
}
pub fn Curve::default() -> Self
pub fn Curve::evaluate(Self, Double) -> Vector
pub fn Curve::from_quadratic(Vector, Vector, Vector) -> Self
pub fn Curve::is_line(Self, Double) -> Bool
pub fn Curve::length(Self) -> Double
pub fn Curve::new(Vector, Vector, Vector, Vector) -> Self
pub fn Curve::reverse(Self) -> Self
pub fn Curve::slice(Self, Double, Double) -> Self
pub fn Curve::time(Self, Double, Double) -> SegmentTime

pub(all) enum Fill {
  NonZero
  EvenOdd
}

pub struct FixedPoint {
  mut x : Int
  mut y : Int
}
pub fn FixedPoint::default() -> Self
pub fn FixedPoint::from_point(Vector) -> Self
pub fn FixedPoint::new(Int, Int) -> Self

pub(all) enum Format {
  Alpha
  Subpixel
  CustomSubpixel(Array[Double])
}
pub fn Format::buffer_size(Self, UInt, UInt) -> Int
pub fn Format::subpixel_bgra() -> Self

pub struct HeapStorage {
  mut min : FixedPoint
  mut max : FixedPoint
  cells : Array[Cell]
  indices : Array[Int]
}
pub fn HeapStorage::new() -> Self

pub(all) enum Join {
  Bevel
  Miter
  Round
}

pub struct Line {
  a : Vector
  b : Vector
}
pub fn Line::length(Self) -> Double
pub fn Line::new(Vector, Vector) -> Self
pub fn Line::reverse(Self) -> Self
pub fn Line::slice(Self, Double, Double) -> Self
pub fn Line::time(Self, Double) -> SegmentTime

pub struct Mask {
  data : &PathData
  mut style : Style
  mut transform : Transform?
  mut format : Format
  mut origin : Origin
  mut offset : Vector
  mut render_offset : Vector
  mut width : UInt
  mut height : UInt
  mut explicit_size : Bool
  mut has_size : Bool
  mut bounds_offset : Vector
  scratch : Ref[Scratch]?
}
pub fn Mask::format(Self, Format) -> Self
pub fn Mask::inspect(Self, (Format, UInt, UInt) -> Unit) -> Self
pub fn Mask::new(&PathData) -> Self
pub fn Mask::offset(Self, Vector) -> Self
pub fn Mask::origin(Self, Origin) -> Self
pub fn Mask::render(Self) -> (Array[Byte], Placement)
pub fn Mask::render_into(Self, Array[Byte], pitch? : Int) -> Placement
pub fn Mask::render_offset(Self, Vector) -> Self
pub fn Mask::size(Self, UInt, UInt) -> Self
pub fn Mask::style(Self, Style) -> Self
pub fn Mask::transform(Self, Transform?) -> Self
pub fn Mask::with_scratch(&PathData, Ref[Scratch]) -> Self

pub(all) enum Origin {
  TopLeft
  BottomLeft
}

pub(all) struct Placement {
  left : Int
  top : Int
  width : UInt
  height : UInt
}
pub fn Placement::compute(Origin, Vector, Bounds) -> (Vector, Self)

pub struct PointsCommands {
  points : Array[Vector]
  verbs : Array[Verb]
  mut ppos : Int
  mut vpos : Int
}
pub fn PointsCommands::new(Array[Vector], Array[Verb]) -> Self
pub fn PointsCommands::next(Self) -> Command?

pub struct PointsVerbsPathData {
  points : Array[Vector]
  verbs : Array[Verb]
}
pub fn PointsVerbsPathData::new(Array[Vector], Array[Verb]) -> Self
pub impl PathData for PointsVerbsPathData

pub struct Rasterizer {
  storage : HeapStorage
  mut xmin : Int
  mut xmax : Int
  mut ymin : Int
  mut ymax : Int
  mut height : Int
  mut shift : Vector
  mut start : FixedPoint
  mut closed : Bool
  mut current : Vector
  mut x : Int
  mut y : Int
  mut px : Int
  mut py : Int
  mut cover : Int
  mut area : Int
  mut invalid : Bool
}
pub fn Rasterizer::new(HeapStorage) -> Self
pub fn Rasterizer::rasterize(Self, Vector, UInt, UInt, (Self) -> Unit, Fill, Array[Byte], Int, Bool) -> Unit
pub fn Rasterizer::rasterize_write(Self, Vector, UInt, UInt, (Self) -> Unit, Fill, Int, Bool, (Int, Int, Int, Byte) -> Unit) -> Unit
pub fn Rasterizer::storage(Self) -> HeapStorage
pub impl PathBuilder for Rasterizer

pub struct Scratch {
  segments : Array[Segment]
  mut render : HeapStorage
}
pub fn Scratch::apply(Self, &PathData, Style, Transform?, &PathBuilder) -> Fill
pub fn Scratch::bounds(Self, &PathData, Style, Transform?) -> Bounds
pub fn Scratch::clear(Self) -> Unit
pub fn Scratch::default() -> Self
pub fn Scratch::new() -> Self
pub fn Scratch::render_storage(Self) -> HeapStorage
pub fn Scratch::set_render_storage(Self, HeapStorage) -> Unit

pub enum Segment {
  Line(Int, Line)
  Curve(Int, Curve)
  End(Bool)
}
pub fn Segment::default() -> Self
pub fn Segment::length(Self) -> Double
pub fn Segment::point_normal(Self, Double) -> (Vector, Vector)
pub fn Segment::reverse(Self) -> Self
pub fn Segment::slice(Self, Double, Double) -> Self
pub fn Segment::time(Self, Double, Double) -> SegmentTime

pub struct SegmentTime {
  distance : Double
  time : Double
}

pub struct Segments {
  commands : Array[Command]
  mut index : Int
  mut start : Vector
  mut prev : Vector
  mut close : Bool
  split : Bool
  splits : Array[Curve]
  mut split_count : Int
  mut split_index : Int
  mut last_was_end : Bool
  mut id : Int
  mut count : UInt
}
pub fn Segments::new(Bool, Array[Command]) -> Self
pub fn Segments::next(Self) -> Segment?

type State

pub struct Stroke {
  mut width : Double
  mut join : Join
  mut miter_limit : Double
  mut start_cap : Cap
  mut end_cap : Cap
  mut dashes : Array[Double]
  mut offset : Double
  mut scale : Bool
}
pub fn Stroke::cap(Self, Cap) -> Self
pub fn Stroke::caps(Self, Cap, Cap) -> Self
pub fn Stroke::dash(Self, Array[Double], Double) -> Self
pub fn Stroke::default() -> Self
pub fn Stroke::join(Self, Join) -> Self
pub fn Stroke::miter_limit(Self, Double) -> Self
pub fn Stroke::new(Double) -> Self
pub fn Stroke::scale(Self, Bool) -> Self
pub fn Stroke::width(Self, Double) -> Self

pub(all) enum Style {
  Fill(Fill)
  Stroke(Stroke)
}
pub fn Style::default() -> Self
pub fn Style::is_stroke(Self) -> Bool

pub struct SvgCommands {
  source : String
  mut cur : Int
  mut pos : Int
  mut cmd_pos : Int
  mut error : Bool
  mut done : Bool
  mut start_point : Vector
  mut cur_point : Vector
  mut last_control : Vector
  mut last_cmd : Int
  mut state : State
  mut arc : Arc
}
pub fn SvgCommands::new(String) -> Self
pub fn SvgCommands::next(Self) -> Command?

pub struct Transform {
  xx : Double
  xy : Double
  yx : Double
  yy : Double
  x : Double
  y : Double
}
pub fn Transform::identity() -> Self
pub fn Transform::scale(Double, Double) -> Self
pub fn Transform::transform_point(Self, Vector) -> Vector
pub fn Transform::transform_vector(Self, Vector) -> Vector
pub fn Transform::translate(Double, Double) -> Self

pub struct TransformSink {
  sink : &PathBuilder
  transform : Transform
}
pub impl PathBuilder for TransformSink

#alias(Point)
pub struct Vector {
  x : Double
  y : Double
}
pub fn Vector::ceil(Self) -> Self
pub fn Vector::cross(Self, Self) -> Double
pub fn Vector::distance_to(Self, Self) -> Double
pub fn Vector::div_scalar(Self, Double) -> Self
pub fn Vector::dot(Self, Self) -> Double
pub fn Vector::floor(Self) -> Self
pub fn Vector::length(Self) -> Double
pub fn Vector::length_squared(Self) -> Double
pub fn Vector::nearly_eq(Self, Self) -> Bool
pub fn Vector::nearly_eq_by(Self, Self, Double) -> Bool
pub fn Vector::new(Double, Double) -> Self
pub fn Vector::normalize(Self) -> Self
pub fn Vector::scale(Self, Double) -> Self
pub fn Vector::x(Self) -> Double
pub fn Vector::y(Self) -> Double
pub fn Vector::zero() -> Self
pub impl Add for Vector
pub impl Div for Vector
pub impl Mul for Vector
pub impl Neg for Vector
pub impl Sub for Vector

pub(all) enum Verb {
  MoveTo
  LineTo
  QuadTo
  CurveTo
  Close
}

pub enum Vertex {
  Start(Vector, Vector)
  Middle(Vector, Vector, Vector)
  End(Vector, Vector, Bool)
}

pub struct Vertices {
  segments : Segments
  mut prev_point : Vector
  mut prev_dir : Vector
  mut is_first : Bool
}
pub fn Vertices::new(&PathData) -> Self
pub fn Vertices::next(Self) -> Vertex?
pub fn Vertices::with_transform(&PathData, Transform) -> Self

pub struct Walk {
  commands : Array[Command]
  iter : Segments
  mut segment : Segment
  mut segment_offset : Double
  mut first : Bool
  mut length : Double?
  mut walked : Double
}
pub fn Walk::new(&PathData) -> Self
pub fn Walk::remaining(Self) -> Double
pub fn Walk::step(Self, Double) -> (Vector, Vector)?
pub fn Walk::with_transform(&PathData, Transform) -> Self

// Type aliases
pub type SegmentId = Int

// Traits
pub(open) trait PathBuilder {
  move_to(Self, Vector) -> Unit
  line_to(Self, Vector) -> Unit
  quad_to(Self, Vector, Vector) -> Unit
  curve_to(Self, Vector, Vector, Vector) -> Unit
  close(Self) -> Unit
}

pub(open) trait PathData {
  commands(Self) -> Iter[Command]
  copy_to(Self, &PathBuilder) -> Unit
}
pub impl PathData for String
pub impl PathData for Array[Command]

