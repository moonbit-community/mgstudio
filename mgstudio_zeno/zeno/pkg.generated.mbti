// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mgstudio_zeno/zeno"

// Values
pub fn apply(&PathData, Style, Transform?, &PathBuilder) -> Fill

pub fn bounds(&PathData, Style, Transform?) -> Bounds

// Errors

// Types and methods
pub struct Bounds {
  mut min : Vector
  mut max : Vector
  mut empty : Bool
}
pub fn Bounds::add_point(Self, Vector) -> Unit
pub fn Bounds::from_points(Array[Vector]) -> Self
pub fn Bounds::height(Self) -> Double
pub fn Bounds::is_empty(Self) -> Bool
pub fn Bounds::new(Vector, Vector) -> Self
pub fn Bounds::width(Self) -> Double

pub struct BoundsBuilder {
  mut count : Int
  mut min : Vector
  mut max : Vector
}
pub fn BoundsBuilder::new() -> Self
pub impl PathBuilder for BoundsBuilder

pub(all) enum Cap {
  Butt
  Square
  Round
}

pub struct Cell {
  x : Int
  mut cover : Int
  mut area : Int
  mut next : Int
}

pub(all) enum Command {
  MoveTo(Vector)
  LineTo(Vector)
  QuadTo(Vector, Vector)
  CurveTo(Vector, Vector, Vector)
  Close
}
pub fn Command::transform(Self, Transform) -> Self

pub(all) enum Fill {
  NonZero
  EvenOdd
}

pub struct FixedPoint {
  mut x : Int
  mut y : Int
}
pub fn FixedPoint::default() -> Self
pub fn FixedPoint::from_point(Vector) -> Self
pub fn FixedPoint::new(Int, Int) -> Self

pub(all) enum Format {
  Alpha
  Subpixel
  CustomSubpixel(Array[Double])
}
pub fn Format::buffer_size(Self, UInt, UInt) -> Int
pub fn Format::subpixel_bgra() -> Self

pub struct HeapStorage {
  mut min : FixedPoint
  mut max : FixedPoint
  cells : Array[Cell]
  indices : Array[Int]
}
pub fn HeapStorage::new() -> Self

pub(all) enum Join {
  Bevel
  Miter
  Round
}

pub struct Mask {
  data : &PathData
  mut style : Style
  mut transform : Transform?
  mut format : Format
  mut origin : Origin
  mut offset : Vector
  mut render_offset : Vector
  mut width : UInt
  mut height : UInt
  mut explicit_size : Bool
  mut has_size : Bool
  mut bounds_offset : Vector
  scratch : Ref[Scratch]?
}
pub fn Mask::format(Self, Format) -> Self
pub fn Mask::inspect(Self, (Format, UInt, UInt) -> Unit) -> Self
pub fn Mask::new(&PathData) -> Self
pub fn Mask::offset(Self, Vector) -> Self
pub fn Mask::origin(Self, Origin) -> Self
pub fn Mask::render(Self) -> (Array[Byte], Placement)
pub fn Mask::render_into(Self, Array[Byte], pitch? : Int) -> Placement
pub fn Mask::render_offset(Self, Vector) -> Self
pub fn Mask::size(Self, UInt, UInt) -> Self
pub fn Mask::style(Self, Style) -> Self
pub fn Mask::transform(Self, Transform?) -> Self
pub fn Mask::with_scratch(&PathData, Ref[Scratch]) -> Self

pub(all) enum Origin {
  TopLeft
  BottomLeft
}

pub(all) struct Placement {
  left : Int
  top : Int
  width : UInt
  height : UInt
}
pub fn Placement::compute(Origin, Vector, Bounds) -> (Vector, Self)

pub struct PointsCommands {
  points : Array[Vector]
  verbs : Array[Verb]
  mut ppos : Int
  mut vpos : Int
}
pub fn PointsCommands::new(Array[Vector], Array[Verb]) -> Self
pub fn PointsCommands::next(Self) -> Command?

pub struct PointsVerbsPathData {
  points : Array[Vector]
  verbs : Array[Verb]
}
pub fn PointsVerbsPathData::new(Array[Vector], Array[Verb]) -> Self
pub impl PathData for PointsVerbsPathData

pub struct Rasterizer {
  storage : HeapStorage
  mut xmin : Int
  mut xmax : Int
  mut ymin : Int
  mut ymax : Int
  mut height : Int
  mut shift : Vector
  mut start : FixedPoint
  mut closed : Bool
  mut current : Vector
  mut x : Int
  mut y : Int
  mut px : Int
  mut py : Int
  mut cover : Int
  mut area : Int
  mut invalid : Bool
}
pub fn Rasterizer::new(HeapStorage) -> Self
pub fn Rasterizer::rasterize(Self, Vector, UInt, UInt, (Self) -> Unit, Fill, Array[Byte], Int, Bool) -> Unit
pub fn Rasterizer::rasterize_write(Self, Vector, UInt, UInt, (Self) -> Unit, Fill, Int, Bool, (Int, Int, Int, Byte) -> Unit) -> Unit
pub fn Rasterizer::storage(Self) -> HeapStorage
pub impl PathBuilder for Rasterizer

pub struct Scratch {
  mut render : HeapStorage
}
pub fn Scratch::apply(Self, &PathData, Style, Transform?, &PathBuilder) -> Fill
pub fn Scratch::bounds(Self, &PathData, Style, Transform?) -> Bounds
pub fn Scratch::clear(Self) -> Unit
pub fn Scratch::default() -> Self
pub fn Scratch::new() -> Self
pub fn Scratch::render_storage(Self) -> HeapStorage
pub fn Scratch::set_render_storage(Self, HeapStorage) -> Unit

pub struct Stroke {
  mut width : Double
  mut join : Join
  mut miter_limit : Double
  mut start_cap : Cap
  mut end_cap : Cap
  mut dashes : Array[Double]
  mut offset : Double
  mut scale : Bool
}
pub fn Stroke::cap(Self, Cap) -> Self
pub fn Stroke::caps(Self, Cap, Cap) -> Self
pub fn Stroke::dash(Self, Array[Double], Double) -> Self
pub fn Stroke::default() -> Self
pub fn Stroke::join(Self, Join) -> Self
pub fn Stroke::miter_limit(Self, Double) -> Self
pub fn Stroke::new(Double) -> Self
pub fn Stroke::scale(Self, Bool) -> Self
pub fn Stroke::width(Self, Double) -> Self

pub(all) enum Style {
  Fill(Fill)
  Stroke(Stroke)
}
pub fn Style::default() -> Self
pub fn Style::is_stroke(Self) -> Bool

pub struct Transform {
  xx : Double
  xy : Double
  yx : Double
  yy : Double
  x : Double
  y : Double
}
pub fn Transform::identity() -> Self
pub fn Transform::scale(Double, Double) -> Self
pub fn Transform::transform_point(Self, Vector) -> Vector
pub fn Transform::transform_vector(Self, Vector) -> Vector
pub fn Transform::translate(Double, Double) -> Self

pub struct TransformSink {
  sink : &PathBuilder
  transform : Transform
}
pub impl PathBuilder for TransformSink

#alias(Point)
pub struct Vector {
  x : Double
  y : Double
}
pub fn Vector::ceil(Self) -> Self
pub fn Vector::floor(Self) -> Self
pub fn Vector::length(Self) -> Double
pub fn Vector::new(Double, Double) -> Self
pub fn Vector::x(Self) -> Double
pub fn Vector::y(Self) -> Double
pub impl Add for Vector

pub(all) enum Verb {
  MoveTo
  LineTo
  QuadTo
  CurveTo
  Close
}

// Type aliases

// Traits
pub(open) trait PathBuilder {
  move_to(Self, Vector) -> Unit
  line_to(Self, Vector) -> Unit
  quad_to(Self, Vector, Vector) -> Unit
  curve_to(Self, Vector, Vector, Vector) -> Unit
  close(Self) -> Unit
}

pub(open) trait PathData {
  commands(Self) -> Iter[Command]
  copy_to(Self, &PathBuilder) -> Unit
}

